diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/SoftwareVsyncSource.cpp gfx/thebes-patched/SoftwareVsyncSource.cpp
--- gfx/thebes/SoftwareVsyncSource.cpp	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/SoftwareVsyncSource.cpp	2016-12-20 18:51:49.000000000 +0100
@@ -13,138 +13,8 @@
 
 SoftwareVsyncSource::SoftwareVsyncSource()
 {
-  MOZ_ASSERT(NS_IsMainThread());
-  mGlobalDisplay = new SoftwareDisplay();
 }
 
 SoftwareVsyncSource::~SoftwareVsyncSource()
 {
-  MOZ_ASSERT(NS_IsMainThread());
-  mGlobalDisplay = nullptr;
-}
-
-SoftwareDisplay::SoftwareDisplay()
-  : mVsyncEnabled(false)
-{
-  // Mimic 60 fps
-  MOZ_ASSERT(NS_IsMainThread());
-  const double rate = 1000.0 / (double) gfxPlatform::GetSoftwareVsyncRate();
-  mVsyncRate = mozilla::TimeDuration::FromMilliseconds(rate);
-  mVsyncThread = new base::Thread("SoftwareVsyncThread");
-  MOZ_RELEASE_ASSERT(mVsyncThread->Start(), "GFX: Could not start software vsync thread");
-}
-
-SoftwareDisplay::~SoftwareDisplay() {}
-
-void
-SoftwareDisplay::EnableVsync()
-{
-  MOZ_ASSERT(mVsyncThread->IsRunning());
-  if (NS_IsMainThread()) {
-    if (mVsyncEnabled) {
-      return;
-    }
-    mVsyncEnabled = true;
-
-    mVsyncThread->message_loop()->PostTask(
-      NewRunnableMethod(this, &SoftwareDisplay::EnableVsync));
-    return;
-  }
-
-  MOZ_ASSERT(IsInSoftwareVsyncThread());
-  NotifyVsync(mozilla::TimeStamp::Now());
-}
-
-void
-SoftwareDisplay::DisableVsync()
-{
-  MOZ_ASSERT(mVsyncThread->IsRunning());
-  if (NS_IsMainThread()) {
-    if (!mVsyncEnabled) {
-      return;
-    }
-    mVsyncEnabled = false;
-
-    mVsyncThread->message_loop()->PostTask(
-      NewRunnableMethod(this, &SoftwareDisplay::DisableVsync));
-    return;
-  }
-
-  MOZ_ASSERT(IsInSoftwareVsyncThread());
-  if (mCurrentVsyncTask) {
-    mCurrentVsyncTask->Cancel();
-    mCurrentVsyncTask = nullptr;
-  }
-}
-
-bool
-SoftwareDisplay::IsVsyncEnabled()
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  return mVsyncEnabled;
-}
-
-bool
-SoftwareDisplay::IsInSoftwareVsyncThread()
-{
-  return mVsyncThread->thread_id() == PlatformThread::CurrentId();
-}
-
-void
-SoftwareDisplay::NotifyVsync(mozilla::TimeStamp aVsyncTimestamp)
-{
-  MOZ_ASSERT(IsInSoftwareVsyncThread());
-
-  mozilla::TimeStamp displayVsyncTime = aVsyncTimestamp;
-  mozilla::TimeStamp now = mozilla::TimeStamp::Now();
-  // Posted tasks can only have integer millisecond delays
-  // whereas TimeDurations can have floating point delays.
-  // Thus the vsync timestamp can be in the future, which large parts
-  // of the system can't handle, including animations. Force the timestamp to be now.
-  if (aVsyncTimestamp > now) {
-    displayVsyncTime = now;
-  }
-
-  Display::NotifyVsync(displayVsyncTime);
-
-  // Prevent skew by still scheduling based on the original
-  // vsync timestamp
-  ScheduleNextVsync(aVsyncTimestamp);
-}
-
-mozilla::TimeDuration
-SoftwareDisplay::GetVsyncRate()
-{
-  return mVsyncRate;
-}
-
-void
-SoftwareDisplay::ScheduleNextVsync(mozilla::TimeStamp aVsyncTimestamp)
-{
-  MOZ_ASSERT(IsInSoftwareVsyncThread());
-  mozilla::TimeStamp nextVsync = aVsyncTimestamp + mVsyncRate;
-  mozilla::TimeDuration delay = nextVsync - mozilla::TimeStamp::Now();
-  if (delay.ToMilliseconds() < 0) {
-    delay = mozilla::TimeDuration::FromMilliseconds(0);
-    nextVsync = mozilla::TimeStamp::Now();
-  }
-
-  mCurrentVsyncTask =
-    NewCancelableRunnableMethod<mozilla::TimeStamp>(this,
-                                                    &SoftwareDisplay::NotifyVsync,
-                                                    nextVsync);
-
-  RefPtr<Runnable> addrefedTask = mCurrentVsyncTask;
-  mVsyncThread->message_loop()->PostDelayedTask(
-    addrefedTask.forget(),
-    delay.ToMilliseconds());
-}
-
-void
-SoftwareDisplay::Shutdown()
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  DisableVsync();
-  mVsyncThread->Stop();
-  delete mVsyncThread;
 }
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/SoftwareVsyncSource.h gfx/thebes-patched/SoftwareVsyncSource.h
--- gfx/thebes/SoftwareVsyncSource.h	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/SoftwareVsyncSource.h	2016-12-20 18:51:49.000000000 +0100
@@ -14,32 +14,6 @@
 #include "nsISupportsImpl.h"
 #include "VsyncSource.h"
 
-class SoftwareDisplay final : public mozilla::gfx::VsyncSource::Display
-{
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(SoftwareDisplay)
-
-public:
-  SoftwareDisplay();
-  virtual void EnableVsync() override;
-  virtual void DisableVsync() override;
-  virtual bool IsVsyncEnabled() override;
-  bool IsInSoftwareVsyncThread();
-  virtual void NotifyVsync(mozilla::TimeStamp aVsyncTimestamp) override;
-  virtual mozilla::TimeDuration GetVsyncRate() override;
-  void ScheduleNextVsync(mozilla::TimeStamp aVsyncTimestamp);
-  void Shutdown() override;
-
-protected:
-  ~SoftwareDisplay();
-
-private:
-  mozilla::TimeDuration mVsyncRate;
-  // Use a chromium thread because nsITimers* fire on the main thread
-  base::Thread* mVsyncThread;
-  RefPtr<mozilla::CancelableRunnable> mCurrentVsyncTask; // only access on vsync thread
-  bool mVsyncEnabled; // Only access on main thread
-}; // SoftwareDisplay
-
 // Fallback option to use a software timer to mimic vsync. Useful for gtests
 // To mimic a hardware vsync thread, we create a dedicated software timer
 // vsync thread.
@@ -49,14 +23,6 @@
   SoftwareVsyncSource();
   ~SoftwareVsyncSource();
 
-  virtual Display& GetGlobalDisplay() override
-  {
-    MOZ_ASSERT(mGlobalDisplay != nullptr);
-    return *mGlobalDisplay;
-  }
-
-private:
-  RefPtr<SoftwareDisplay> mGlobalDisplay;
 };
 
 #endif /* GFX_SOFTWARE_VSYNC_SOURCE_H */
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/VsyncSource.cpp gfx/thebes-patched/VsyncSource.cpp
--- gfx/thebes/VsyncSource.cpp	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/VsyncSource.cpp	2016-12-20 18:51:49.000000000 +0100
@@ -8,146 +8,3 @@
 #include "nsXULAppAPI.h"
 #include "mozilla/VsyncDispatcher.h"
 #include "MainThreadUtils.h"
-
-namespace mozilla {
-namespace gfx {
-
-void
-VsyncSource::AddCompositorVsyncDispatcher(CompositorVsyncDispatcher* aCompositorVsyncDispatcher)
-{
-  MOZ_ASSERT(XRE_IsParentProcess());
-  MOZ_ASSERT(NS_IsMainThread());
-  // Just use the global display until we have enough information to get the
-  // corresponding display for compositor.
-  GetGlobalDisplay().AddCompositorVsyncDispatcher(aCompositorVsyncDispatcher);
-}
-
-void
-VsyncSource::RemoveCompositorVsyncDispatcher(CompositorVsyncDispatcher* aCompositorVsyncDispatcher)
-{
-  MOZ_ASSERT(XRE_IsParentProcess());
-  MOZ_ASSERT(NS_IsMainThread());
-  // See also AddCompositorVsyncDispatcher().
-  GetGlobalDisplay().RemoveCompositorVsyncDispatcher(aCompositorVsyncDispatcher);
-}
-
-RefPtr<RefreshTimerVsyncDispatcher>
-VsyncSource::GetRefreshTimerVsyncDispatcher()
-{
-  MOZ_ASSERT(XRE_IsParentProcess());
-  // See also AddCompositorVsyncDispatcher().
-  return GetGlobalDisplay().GetRefreshTimerVsyncDispatcher();
-}
-
-VsyncSource::Display::Display()
-  : mDispatcherLock("display dispatcher lock")
-  , mRefreshTimerNeedsVsync(false)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  mRefreshTimerVsyncDispatcher = new RefreshTimerVsyncDispatcher();
-}
-
-VsyncSource::Display::~Display()
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  MutexAutoLock lock(mDispatcherLock);
-  mRefreshTimerVsyncDispatcher = nullptr;
-  mCompositorVsyncDispatchers.Clear();
-}
-
-void
-VsyncSource::Display::NotifyVsync(TimeStamp aVsyncTimestamp)
-{
-  // Called on the vsync thread
-  MutexAutoLock lock(mDispatcherLock);
-
-  for (size_t i = 0; i < mCompositorVsyncDispatchers.Length(); i++) {
-    mCompositorVsyncDispatchers[i]->NotifyVsync(aVsyncTimestamp);
-  }
-
-  mRefreshTimerVsyncDispatcher->NotifyVsync(aVsyncTimestamp);
-}
-
-TimeDuration
-VsyncSource::Display::GetVsyncRate()
-{
-  // If hardware queries fail / are unsupported, we have to just guess.
-  return TimeDuration::FromMilliseconds(1000.0 / 60.0);
-}
-
-void
-VsyncSource::Display::AddCompositorVsyncDispatcher(CompositorVsyncDispatcher* aCompositorVsyncDispatcher)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(aCompositorVsyncDispatcher);
-  { // scope lock
-    MutexAutoLock lock(mDispatcherLock);
-    if (!mCompositorVsyncDispatchers.Contains(aCompositorVsyncDispatcher)) {
-      mCompositorVsyncDispatchers.AppendElement(aCompositorVsyncDispatcher);
-    }
-  }
-  UpdateVsyncStatus();
-}
-
-void
-VsyncSource::Display::RemoveCompositorVsyncDispatcher(CompositorVsyncDispatcher* aCompositorVsyncDispatcher)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(aCompositorVsyncDispatcher);
-  { // Scope lock
-    MutexAutoLock lock(mDispatcherLock);
-    if (mCompositorVsyncDispatchers.Contains(aCompositorVsyncDispatcher)) {
-      mCompositorVsyncDispatchers.RemoveElement(aCompositorVsyncDispatcher);
-    }
-  }
-  UpdateVsyncStatus();
-}
-
-void
-VsyncSource::Display::NotifyRefreshTimerVsyncStatus(bool aEnable)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  mRefreshTimerNeedsVsync = aEnable;
-  UpdateVsyncStatus();
-}
-
-void
-VsyncSource::Display::UpdateVsyncStatus()
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  // WARNING: This function SHOULD NOT BE CALLED WHILE HOLDING LOCKS
-  // NotifyVsync grabs a lock to dispatch vsync events
-  // When disabling vsync, we wait for the underlying thread to stop on some platforms
-  // We can deadlock if we wait for the underlying vsync thread to stop
-  // while the vsync thread is in NotifyVsync.
-  bool enableVsync = false;
-  { // scope lock
-    MutexAutoLock lock(mDispatcherLock);
-    enableVsync = !mCompositorVsyncDispatchers.IsEmpty() || mRefreshTimerNeedsVsync;
-  }
-
-  if (enableVsync) {
-    EnableVsync();
-  } else {
-    DisableVsync();
-  }
-
-  if (IsVsyncEnabled() != enableVsync) {
-    NS_WARNING("Vsync status did not change.");
-  }
-}
-
-RefPtr<RefreshTimerVsyncDispatcher>
-VsyncSource::Display::GetRefreshTimerVsyncDispatcher()
-{
-  return mRefreshTimerVsyncDispatcher;
-}
-
-void
-VsyncSource::Shutdown()
-{
-  GetGlobalDisplay().Shutdown();
-}
-
-} //namespace gfx
-} //namespace mozilla
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/VsyncSource.h gfx/thebes-patched/VsyncSource.h
--- gfx/thebes/VsyncSource.h	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/VsyncSource.h	2016-12-20 18:51:49.000000000 +0100
@@ -13,8 +13,6 @@
 #include "nsISupportsImpl.h"
 
 namespace mozilla {
-class RefreshTimerVsyncDispatcher;
-class CompositorVsyncDispatcher;
 
 namespace gfx {
 
@@ -24,56 +22,6 @@
 {
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(VsyncSource)
 
-  typedef mozilla::RefreshTimerVsyncDispatcher RefreshTimerVsyncDispatcher;
-  typedef mozilla::CompositorVsyncDispatcher CompositorVsyncDispatcher;
-
-public:
-  // Controls vsync unique to each display and unique on each platform
-  class Display {
-    public:
-      Display();
-      virtual ~Display();
-
-      // Notified when this display's vsync occurs, on the vsync thread
-      // The aVsyncTimestamp should normalize to the Vsync time that just occured
-      // However, different platforms give different vsync notification times.
-      // b2g - The vsync timestamp of the previous frame that was just displayed
-      // OSX - The vsync timestamp of the upcoming frame, in the future
-      // Windows: It's messy, see gfxWindowsPlatform.
-      // Android: TODO
-      // All platforms should normalize to the vsync that just occured.
-      // Large parts of Gecko assume TimeStamps should not be in the future such as animations
-      virtual void NotifyVsync(TimeStamp aVsyncTimestamp);
-
-      RefPtr<RefreshTimerVsyncDispatcher> GetRefreshTimerVsyncDispatcher();
-
-      void AddCompositorVsyncDispatcher(CompositorVsyncDispatcher* aCompositorVsyncDispatcher);
-      void RemoveCompositorVsyncDispatcher(CompositorVsyncDispatcher* aCompositorVsyncDispatcher);
-      void NotifyRefreshTimerVsyncStatus(bool aEnable);
-      virtual TimeDuration GetVsyncRate();
-
-      // These should all only be called on the main thread
-      virtual void EnableVsync() = 0;
-      virtual void DisableVsync() = 0;
-      virtual bool IsVsyncEnabled() = 0;
-      virtual void Shutdown() = 0;
-
-    private:
-      void UpdateVsyncStatus();
-
-      Mutex mDispatcherLock;
-      bool mRefreshTimerNeedsVsync;
-      nsTArray<RefPtr<CompositorVsyncDispatcher>> mCompositorVsyncDispatchers;
-      RefPtr<RefreshTimerVsyncDispatcher> mRefreshTimerVsyncDispatcher;
-  };
-
-  void AddCompositorVsyncDispatcher(CompositorVsyncDispatcher* aCompositorVsyncDispatcher);
-  void RemoveCompositorVsyncDispatcher(CompositorVsyncDispatcher* aCompositorVsyncDispatcher);
-
-  RefPtr<RefreshTimerVsyncDispatcher> GetRefreshTimerVsyncDispatcher();
-  virtual Display& GetGlobalDisplay() = 0; // Works across all displays
-  void Shutdown();
-
 protected:
   virtual ~VsyncSource() {}
 };
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxFcPlatformFontList.cpp gfx/thebes-patched/gfxFcPlatformFontList.cpp
--- gfx/thebes/gfxFcPlatformFontList.cpp	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxFcPlatformFontList.cpp	2016-12-20 18:51:49.000000000 +0100
@@ -1647,8 +1647,7 @@
     bool prefFontsUseOnlyGenerics = true;
     uint32_t count;
     char** names;
-    nsresult rv = Preferences::GetRootBranch()->
-        GetChildList(kFontNamePrefix, &count, &names);
+    nsresult rv = NS_ERROR_BASE;
     if (NS_SUCCEEDED(rv) && count) {
         for (size_t i = 0; i < count; i++) {
             // Check whether all font.name prefs map to generic keywords
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxFont.cpp gfx/thebes-patched/gfxFont.cpp
--- gfx/thebes/gfxFont.cpp	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxFont.cpp	2016-12-20 18:51:49.000000000 +0100
@@ -166,25 +166,8 @@
 }
 
 gfxFontCache::gfxFontCache()
-    : nsExpirationTracker<gfxFont,3>(FONT_TIMEOUT_SECONDS * 1000,
-                                     "gfxFontCache")
 {
-    nsCOMPtr<nsIObserverService> obs = GetObserverService();
-    if (obs) {
-        obs->AddObserver(new Observer, "memory-pressure", false);
-    }
 
-#ifndef RELEASE_BUILD
-    // Currently disabled for release builds, due to unexplained crashes
-    // during expiration; see bug 717175 & 894798.
-    mWordCacheExpirationTimer = do_CreateInstance("@mozilla.org/timer;1");
-    if (mWordCacheExpirationTimer) {
-        mWordCacheExpirationTimer->
-            InitWithFuncCallback(WordCacheExpirationTimerCallback, this,
-                                 SHAPED_WORD_TIMEOUT_SECONDS * 1000,
-                                 nsITimer::TYPE_REPEATING_SLACK);
-    }
-#endif
 }
 
 gfxFontCache::~gfxFontCache()
@@ -259,6 +242,24 @@
     }
 }
 
+nsresult
+gfxFontCache::AddObject(gfxFont* aFont)
+{
+	return NS_OK;
+}
+
+void
+gfxFontCache::RemoveObject(gfxFont* aFont)
+{
+
+}
+
+void
+gfxFontCache::AgeAllGenerations()
+{
+
+}
+
 void
 gfxFontCache::NotifyReleased(gfxFont *aFont)
 {
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxFont.h gfx/thebes-patched/gfxFont.h
--- gfx/thebes/gfxFont.h	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxFont.h	2016-12-20 18:51:49.000000000 +0100
@@ -276,7 +276,7 @@
     size_t mShapedWords; // memory used by the per-font shapedWord caches
 };
 
-class gfxFontCache final : public nsExpirationTracker<gfxFont,3> {
+class gfxFontCache final {
 public:
     enum {
         FONT_TIMEOUT_SECONDS = 10,
@@ -318,7 +318,7 @@
 
     // This gets called when the timeout has expired on a zero-refcount
     // font; we just delete it.
-    virtual void NotifyExpired(gfxFont *aFont) override;
+    virtual void NotifyExpired(gfxFont *aFont);
 
     // Cleans out the hashtable and removes expired fonts waiting for cleanup.
     // Other gfxFont objects may be still in use but they will be pushed
@@ -328,6 +328,12 @@
         AgeAllGenerations();
     }
 
+    void AgeAllGenerations();
+
+    nsresult AddObject(gfxFont* aFont);
+
+    void RemoveObject(gfxFont* aFont);
+
     void FlushShapedWordCaches();
 
     void AddSizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf,
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxMacPlatformFontList.mm gfx/thebes-patched/gfxMacPlatformFontList.mm
--- gfx/thebes/gfxMacPlatformFontList.mm	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxMacPlatformFontList.mm	2016-12-20 18:51:49.000000000 +0100
@@ -72,6 +72,8 @@
 #include <time.h>
 #include <dlfcn.h>
 
+#include "../../widget/cocoa/nsCocoaFeatures.mm"
+
 using namespace mozilla;
 
 // indexes into the NSArray objects that the Cocoa font manager returns
@@ -103,6 +105,23 @@
     9  // 14
 };
 
+// static
+void
+nsCocoaUtils::GetStringForNSString(const NSString *aSrc, nsAString& aDist)
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  if (!aSrc) {
+    aDist.Truncate();
+    return;
+  }
+
+  aDist.SetLength([aSrc length]);
+  [aSrc getCharacters: reinterpret_cast<unichar*>(aDist.BeginWriting())];
+
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+
 // cache Cocoa's "shared font manager" for performance
 static NSFontManager *sFontManager;
 
@@ -700,8 +719,8 @@
         sizeHint = 128.0;
     }
 
-    nsAutoString key;
-    ToLowerCase(familyName, key);
+    nsAutoString key = familyName;
+    ToLowerCase(key);
 
     gfxFontFamily* familyEntry = new gfxMacFontFamily(familyName, sizeHint);
     table.Put(key, familyEntry);
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxPlatform.cpp gfx/thebes-patched/gfxPlatform.cpp
--- gfx/thebes/gfxPlatform.cpp	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxPlatform.cpp	2016-12-20 18:51:49.000000000 +0100
@@ -192,206 +192,6 @@
     NS_DECL_NSIOBSERVER
 };
 
-/// This override of the LogForwarder, initially used for the critical graphics
-/// errors, is sending the log to the crash annotations as well, but only
-/// if the capacity set with the method below is >= 2.  We always retain the
-/// very first critical message, and the latest capacity-1 messages are
-/// rotated through. Note that we don't expect the total number of times
-/// this gets called to be large - it is meant for critical errors only.
-
-class CrashStatsLogForwarder: public mozilla::gfx::LogForwarder
-{
-public:
-  explicit CrashStatsLogForwarder(const char* aKey);
-  virtual void Log(const std::string& aString) override;
-  virtual void CrashAction(LogReason aReason) override;
-  virtual bool UpdateStringsVector(const std::string& aString) override;
-
-  virtual LoggingRecord LoggingRecordCopy() override;
-
-  void SetCircularBufferSize(uint32_t aCapacity);
-
-private:
-  // Helper for the Log()
-  void UpdateCrashReport();
-
-private:
-  LoggingRecord mBuffer;
-  nsCString mCrashCriticalKey;
-  uint32_t mMaxCapacity;
-  int32_t mIndex;
-  Mutex mMutex;
-};
-
-CrashStatsLogForwarder::CrashStatsLogForwarder(const char* aKey)
-  : mBuffer()
-  , mCrashCriticalKey(aKey)
-  , mMaxCapacity(0)
-  , mIndex(-1)
-  , mMutex("CrashStatsLogForwarder")
-{
-}
-
-void CrashStatsLogForwarder::SetCircularBufferSize(uint32_t aCapacity)
-{
-  MutexAutoLock lock(mMutex);
-
-  mMaxCapacity = aCapacity;
-  mBuffer.reserve(static_cast<size_t>(aCapacity));
-}
-
-LoggingRecord
-CrashStatsLogForwarder::LoggingRecordCopy()
-{
-  MutexAutoLock lock(mMutex);
-  return mBuffer;
-}
-
-bool
-CrashStatsLogForwarder::UpdateStringsVector(const std::string& aString)
-{
-  // We want at least the first one and the last one.  Otherwise, no point.
-  if (mMaxCapacity < 2) {
-    return false;
-  }
-
-  mIndex += 1;
-  MOZ_ASSERT(mIndex >= 0);
-
-  // index will count 0, 1, 2, ..., max-1, 1, 2, ..., max-1, 1, 2, ...
-  int32_t index = mIndex ? (mIndex-1) % (mMaxCapacity-1) + 1 : 0;
-  MOZ_ASSERT(index >= 0 && index < (int32_t)mMaxCapacity);
-  MOZ_ASSERT(index <= mIndex && index <= (int32_t)mBuffer.size());
-
-  bool ignored;
-  double tStamp = (TimeStamp::NowLoRes()-TimeStamp::ProcessCreation(ignored)).ToSecondsSigDigits();
-
-  // Checking for index >= mBuffer.size(), rather than index == mBuffer.size()
-  // just out of paranoia, but we know index <= mBuffer.size().
-  LoggingRecordEntry newEntry(mIndex,aString,tStamp);
-  if (index >= static_cast<int32_t>(mBuffer.size())) {
-    mBuffer.push_back(newEntry);
-  } else {
-    mBuffer[index] = newEntry;
-  }
-  return true;
-}
-
-void CrashStatsLogForwarder::UpdateCrashReport()
-{
-  std::stringstream message;
-  if (XRE_IsParentProcess()) {
-    for(LoggingRecord::iterator it = mBuffer.begin(); it != mBuffer.end(); ++it) {
-      message << "|[" << Get<0>(*it) << "]" << Get<1>(*it) << " (t=" << Get<2>(*it) << ") ";
-    }
-  } else {
-    for(LoggingRecord::iterator it = mBuffer.begin(); it != mBuffer.end(); ++it) {
-      message << "|[C" << Get<0>(*it) << "]" << Get<1>(*it) << " (t=" << Get<2>(*it) << ") ";
-    }
-  }
-
-#ifdef MOZ_CRASHREPORTER
-  nsCString reportString(message.str().c_str());
-  nsresult annotated = CrashReporter::AnnotateCrashReport(mCrashCriticalKey, reportString);
-#else
-  nsresult annotated = NS_ERROR_NOT_IMPLEMENTED;
-#endif
-  if (annotated != NS_OK) {
-    printf("Crash Annotation %s: %s",
-           mCrashCriticalKey.get(), message.str().c_str());
-  }
-}
-
-class LogForwarderEvent : public Runnable
-{
-  virtual ~LogForwarderEvent() {}
-
-  NS_DECL_ISUPPORTS_INHERITED
-
-  explicit LogForwarderEvent(const nsCString& aMessage) : mMessage(aMessage) {}
-
-  NS_IMETHOD Run() override {
-    MOZ_ASSERT(NS_IsMainThread() && XRE_IsContentProcess());
-    dom::ContentChild* cc = dom::ContentChild::GetSingleton();
-    cc->SendGraphicsError(mMessage);
-    return NS_OK;
-  }
-
-protected:
-  nsCString mMessage;
-};
-
-NS_IMPL_ISUPPORTS_INHERITED0(LogForwarderEvent, Runnable);
-
-void CrashStatsLogForwarder::Log(const std::string& aString)
-{
-  MutexAutoLock lock(mMutex);
-
-  if (UpdateStringsVector(aString)) {
-    UpdateCrashReport();
-  }
-
-  // Add it to the parent strings
-  if (!XRE_IsParentProcess()) {
-    nsCString stringToSend(aString.c_str());
-    if (NS_IsMainThread()) {
-      dom::ContentChild* cc = dom::ContentChild::GetSingleton();
-      cc->SendGraphicsError(stringToSend);
-    } else {
-      nsCOMPtr<nsIRunnable> r1 = new LogForwarderEvent(stringToSend);
-      NS_DispatchToMainThread(r1);
-    }
-  }
-}
-
-class CrashTelemetryEvent : public Runnable
-{
-  virtual ~CrashTelemetryEvent() {}
-
-  NS_DECL_ISUPPORTS_INHERITED
-
-  explicit CrashTelemetryEvent(uint32_t aReason) : mReason(aReason) {}
-
-  NS_IMETHOD Run() override {
-    MOZ_ASSERT(NS_IsMainThread());
-    Telemetry::Accumulate(Telemetry::GFX_CRASH, mReason);
-    return NS_OK;
-  }
-
-protected:
-  uint32_t mReason;
-};
-
-NS_IMPL_ISUPPORTS_INHERITED0(CrashTelemetryEvent, Runnable);
-
-void
-CrashStatsLogForwarder::CrashAction(LogReason aReason)
-{
-#ifndef RELEASE_BUILD
-  // Non-release builds crash by default, but will use telemetry
-  // if this environment variable is present.
-  static bool useTelemetry = gfxEnv::GfxDevCrashTelemetry();
-#else
-  // Release builds use telemetry by default, but will crash instead
-  // if this environment variable is present.
-  static bool useTelemetry = !gfxEnv::GfxDevCrashMozCrash();
-#endif
-
-  if (useTelemetry) {
-    // The callers need to assure that aReason is in the range
-    // that the telemetry call below supports.
-    if (NS_IsMainThread()) {
-      Telemetry::Accumulate(Telemetry::GFX_CRASH, (uint32_t)aReason);
-    } else {
-      nsCOMPtr<nsIRunnable> r1 = new CrashTelemetryEvent((uint32_t)aReason);
-      NS_DispatchToMainThread(r1);
-    }
-  } else {
-    // ignoring aReason, we can get the information we need from the stack
-    MOZ_CRASH("GFX_CRASH");
-  }
-}
-
 NS_IMPL_ISUPPORTS(SRGBOverrideObserver, nsIObserver, nsISupportsWeakReference)
 
 #define GFX_DOWNLOADABLE_FONTS_ENABLED "gfx.downloadable_fonts.enabled"
@@ -480,10 +280,7 @@
 }
 
 gfxPlatform::gfxPlatform()
-  : mAzureCanvasBackendCollector(this, &gfxPlatform::GetAzureBackendInfo)
-  , mApzSupportCollector(this, &gfxPlatform::GetApzSupportInfo)
-  , mTilesInfoCollector(this, &gfxPlatform::GetTilesSupportInfo)
-  , mCompositorBackend(layers::LayersBackend::LAYERS_NONE)
+  : mCompositorBackend(layers::LayersBackend::LAYERS_NONE)
   , mScreenDepth(0)
   , mDeviceCounter(0)
 {
@@ -506,7 +303,6 @@
 #endif
     InitBackendPrefs(canvasMask, BackendType::CAIRO,
                      contentMask, BackendType::CAIRO);
-    mTotalSystemMemory = mozilla::hal::GetTotalSystemMemory();
 
     VRManager::ManagerInit();
 }
@@ -529,30 +325,6 @@
 void RecordingPrefChanged(const char *aPrefName, void *aClosure)
 {
   if (Preferences::GetBool("gfx.2d.recording", false)) {
-    nsAutoCString fileName;
-    nsAdoptingString prefFileName = Preferences::GetString("gfx.2d.recordingfile");
-
-    if (prefFileName) {
-      fileName.Append(NS_ConvertUTF16toUTF8(prefFileName));
-    } else {
-      nsCOMPtr<nsIFile> tmpFile;
-      if (NS_FAILED(NS_GetSpecialDirectory(NS_OS_TEMP_DIR, getter_AddRefs(tmpFile)))) {
-        return;
-      }
-      fileName.AppendPrintf("moz2drec_%i_%i.aer", XRE_GetProcessType(), getpid());
-
-      nsresult rv = tmpFile->AppendNative(fileName);
-      if (NS_FAILED(rv))
-        return;
-
-      rv = tmpFile->GetNativePath(fileName);
-      if (NS_FAILED(rv))
-        return;
-    }
-
-    gPlatform->mRecorder = Factory::CreateEventRecorderForFile(fileName.BeginReading());
-    printf_stderr("Recording to %s\n", fileName.get());
-    Factory::SetGlobalEventRecorder(gPlatform->mRecorder);
   } else {
     Factory::SetGlobalEventRecorder(nullptr);
   }
@@ -591,55 +363,12 @@
 
     // Initialize the preferences by creating the singleton.
     gfxPrefs::GetSingleton();
-    MediaPrefs::GetSingleton();
     gfxVars::Initialize();
 
     gfxConfig::Init();
 
-    if (XRE_IsParentProcess()) {
-      GPUProcessManager::Initialize();
-    }
-
-    auto fwd = new CrashStatsLogForwarder("GraphicsCriticalError");
-    fwd->SetCircularBufferSize(gfxPrefs::GfxLoggingCrashLength());
-
-    // Drop a note in the crash report if we end up forcing an option that could
-    // destabilize things.  New items should be appended at the end (of an existing
-    // or in a new section), so that we don't have to know the version to interpret
-    // these cryptic strings.
-    {
-      nsAutoCString forcedPrefs;
-      // D2D prefs
-      forcedPrefs.AppendPrintf("FP(D%d%d",
-                               gfxPrefs::Direct2DDisabled(),
-                               gfxPrefs::Direct2DForceEnabled());
-      // Layers prefs
-      forcedPrefs.AppendPrintf("-L%d%d%d%d",
-                               gfxPrefs::LayersAMDSwitchableGfxEnabled(),
-                               gfxPrefs::LayersAccelerationDisabledDoNotUseDirectly(),
-                               gfxPrefs::LayersAccelerationForceEnabledDoNotUseDirectly(),
-                               gfxPrefs::LayersD3D11ForceWARP());
-      // WebGL prefs
-      forcedPrefs.AppendPrintf("-W%d%d%d%d%d%d%d%d",
-                               gfxPrefs::WebGLANGLEForceD3D11(),
-                               gfxPrefs::WebGLANGLEForceWARP(),
-                               gfxPrefs::WebGLDisabled(),
-                               gfxPrefs::WebGLDisableANGLE(),
-                               gfxPrefs::WebGLDXGLEnabled(),
-                               gfxPrefs::WebGLForceEnabled(),
-                               gfxPrefs::WebGLForceLayersReadback(),
-                               gfxPrefs::WebGLForceMSAA());
-      // Prefs that don't fit into any of the other sections
-      forcedPrefs.AppendPrintf("-T%d%d%d%d) ",
-                               gfxPrefs::AndroidRGB16Force(),
-                               gfxPrefs::CanvasAzureAccelerated(),
-                               gfxPrefs::DisableGralloc(),
-                               gfxPrefs::ForceShmemTiles());
-      ScopedGfxFeatureReporter::AppNote(forcedPrefs);
-    }
-
     mozilla::gfx::Config cfg;
-    cfg.mLogForwarder = fwd;
+	
     cfg.mMaxTextureSize = gfxPrefs::MaxTextureSize();
     cfg.mMaxAllocSize = gfxPrefs::MaxAllocSize();
 
@@ -786,8 +515,6 @@
 /* static */ void
 gfxPlatform::InitNullMetadata()
 {
-  ScrollMetadata::sNullMetadata = new ScrollMetadata();
-  ClearOnShutdown(&ScrollMetadata::sNullMetadata);
 }
 
 void
@@ -832,12 +559,6 @@
     gPlatform->mMemoryPressureObserver = nullptr;
     gPlatform->mSkiaGlue = nullptr;
 
-    if (XRE_IsParentProcess()) {
-      gPlatform->mVsyncSource->Shutdown();
-    }
-
-    gPlatform->mVsyncSource = nullptr;
-
 #ifdef MOZ_WIDGET_ANDROID
     // Shut down the texture pool
     TexturePoolOGL::Shutdown();
@@ -856,9 +577,6 @@
     GLContextProviderEGL::Shutdown();
 #endif
 
-    if (XRE_IsParentProcess()) {
-      GPUProcessManager::Shutdown();
-    }
 
     // This is a bit iffy - we're assuming that we were the ones that set the
     // log forwarder in the Factory, so that it's our responsibility to
@@ -889,14 +607,6 @@
       return;
     }
     sLayersIPCIsUp = true;
-
-    if (XRE_IsParentProcess())
-    {
-        layers::CompositorThreadHolder::Start();
-#ifdef MOZ_WIDGET_GONK
-        SharedBufferManagerChild::StartUp();
-#endif
-    }
 }
 
 /* static */ void
@@ -906,29 +616,6 @@
       return;
     }
     sLayersIPCIsUp = false;
-
-    if (XRE_IsContentProcess()) {
-        gfx::VRManagerChild::ShutDown();
-        // cf bug 1215265.
-        if (gfxPrefs::ChildProcessShutdown()) {
-          layers::CompositorBridgeChild::ShutDown();
-          layers::ImageBridgeChild::ShutDown();
-        }
-    } else if (XRE_IsParentProcess()) {
-        gfx::VRManagerChild::ShutDown();
-        layers::CompositorBridgeChild::ShutDown();
-        layers::ImageBridgeChild::ShutDown();
-
-#ifdef MOZ_WIDGET_GONK
-        layers::SharedBufferManagerChild::ShutDown();
-#endif
-
-        // This has to happen after shutting down the child protocols.
-        layers::CompositorThreadHolder::Shutdown();
-    } else {
-      // TODO: There are other kind of processes and we should make sure gfx
-      // stuff is either not created there or shut down properly.
-    }
 }
 
 void
@@ -1215,20 +902,6 @@
 void
 gfxPlatform::PopulateScreenInfo()
 {
-  nsCOMPtr<nsIScreenManager> manager = do_GetService("@mozilla.org/gfx/screenmanager;1");
-  MOZ_ASSERT(manager, "failed to get nsIScreenManager");
-
-  nsCOMPtr<nsIScreen> screen;
-  manager->GetPrimaryScreen(getter_AddRefs(screen));
-  if (!screen) {
-    // This can happen in xpcshell, for instance
-    return;
-  }
-
-  screen->GetColorDepth(&mScreenDepth);
-
-  int left, top;
-  screen->GetRect(&left, &top, &mScreenSize.width, &mScreenSize.height);
 }
 
 bool
@@ -2155,11 +1828,6 @@
           NS_LITERAL_CSTRING("FEATURE_FAILURE_NO_E10S"));
       }
     }
-
-    if (gpuProc.IsEnabled()) {
-      GPUProcessManager* gpu = GPUProcessManager::Get();
-      gpu->EnableGPUProcess();
-    }
   }
 
   sLayersAccelerationPrefsInitialized = true;
@@ -2326,33 +1994,11 @@
 void
 gfxPlatform::GetApzSupportInfo(mozilla::widget::InfoObject& aObj)
 {
-  if (!gfxPlatform::AsyncPanZoomEnabled()) {
-    return;
-  }
-
-  if (SupportsApzWheelInput()) {
-    aObj.DefineProperty("ApzWheelInput", 1);
-  }
-
-  if (SupportsApzTouchInput()) {
-    aObj.DefineProperty("ApzTouchInput", 1);
-  }
-
-  if (SupportsApzDragInput()) {
-    aObj.DefineProperty("ApzDragInput", 1);
-  }
 }
 
 void
 gfxPlatform::GetTilesSupportInfo(mozilla::widget::InfoObject& aObj)
 {
-  if (!gfxPrefs::LayersTilesEnabled()) {
-    return;
-  }
-
-  IntSize tileSize = gfxVars::TileSize();
-  aObj.DefineProperty("TileHeight", tileSize.height);
-  aObj.DefineProperty("TileWidth", tileSize.width);
 }
 
 /*static*/ bool
@@ -2436,10 +2082,7 @@
 {
   MOZ_ASSERT(XRE_IsContentProcess());
 
-  mozilla::dom::ContentChild* cc = mozilla::dom::ContentChild::GetSingleton();
-
   mozilla::gfx::ContentDeviceData data;
-  cc->SendGetGraphicsDeviceInitData(&data);
 
   ImportContentDeviceData(data);
 }
@@ -2459,9 +2102,6 @@
 {
   MOZ_ASSERT(XRE_IsParentProcess());
 
-  // Make sure our settings are synchronized from the GPU process.
-  GPUProcessManager::Get()->EnsureGPUReady();
-
   aOut->prefs().hwCompositing() = gfxConfig::GetValue(Feature::HW_COMPOSITING);
   aOut->prefs().oglCompositing() = gfxConfig::GetValue(Feature::OPENGL_COMPOSITING);
 }
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxPlatform.h gfx/thebes-patched/gfxPlatform.h
--- gfx/thebes/gfxPlatform.h	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxPlatform.h	2016-12-20 18:51:49.000000000 +0100
@@ -276,10 +276,6 @@
     static bool AsyncPanZoomEnabled();
 
     virtual void GetAzureBackendInfo(mozilla::widget::InfoObject &aObj) {
-      aObj.DefineProperty("AzureCanvasBackend", GetBackendName(mPreferredCanvasBackend));
-      aObj.DefineProperty("AzureCanvasAccelerated", UseAcceleratedCanvas());
-      aObj.DefineProperty("AzureFallbackCanvasBackend", GetBackendName(mFallbackCanvasBackend));
-      aObj.DefineProperty("AzureContentBackend", GetBackendName(mContentBackend));
     }
     void GetApzSupportInfo(mozilla::widget::InfoObject& aObj);
     void GetTilesSupportInfo(mozilla::widget::InfoObject& aObj);
@@ -818,10 +814,6 @@
     // Bitmask of backend types we can use to render content
     uint32_t mContentBackendBitmask;
 
-    mozilla::widget::GfxInfoCollector<gfxPlatform> mAzureCanvasBackendCollector;
-    mozilla::widget::GfxInfoCollector<gfxPlatform> mApzSupportCollector;
-    mozilla::widget::GfxInfoCollector<gfxPlatform> mTilesInfoCollector;
-
     RefPtr<mozilla::gfx::DrawEventRecorder> mRecorder;
     RefPtr<mozilla::gl::SkiaGLGlue> mSkiaGlue;
 
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxPlatformFontList.cpp gfx/thebes-patched/gfxPlatformFontList.cpp
--- gfx/thebes/gfxPlatformFontList.cpp	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxPlatformFontList.cpp	2016-12-20 18:51:49.000000000 +0100
@@ -24,6 +24,7 @@
 #include "mozilla/Telemetry.h"
 #include "mozilla/TimeStamp.h"
 #include "mozilla/gfx/2D.h"
+#include "nsLanguageAtomService.h"
 
 #include <locale.h>
 
@@ -1160,7 +1161,7 @@
 gfxPlatformFontList::GetLangService()
 {
     if (!mLangService) {
-        mLangService = do_GetService(NS_LANGUAGEATOMSERVICE_CONTRACTID);
+        mLangService = new nsLanguageAtomService();
     }
     NS_ASSERTION(mLangService, "no language service!");
     return mLangService;
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxPlatformGtk.cpp gfx/thebes-patched/gfxPlatformGtk.cpp
--- gfx/thebes/gfxPlatformGtk.cpp	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxPlatformGtk.cpp	2016-12-20 18:51:49.000000000 +0100
@@ -88,8 +88,7 @@
 
 #ifdef MOZ_X11
     if (XRE_IsParentProcess()) {
-      if (GDK_IS_X11_DISPLAY(gdk_display_get_default()) &&
-          mozilla::Preferences::GetBool("gfx.xrender.enabled"))
+      if (mozilla::Preferences::GetBool("gfx.xrender.enabled"))
       {
           gfxVars::SetUseXRender(true);
       }
@@ -104,15 +103,6 @@
 #endif
     InitBackendPrefs(canvasMask, BackendType::CAIRO,
                      contentMask, BackendType::CAIRO);
-
-#ifdef MOZ_X11
-    if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
-      mCompositorDisplay = XOpenDisplay(nullptr);
-      MOZ_ASSERT(mCompositorDisplay, "Failed to create compositor display!");
-    } else {
-      mCompositorDisplay = nullptr;
-    }
-#endif // MOZ_X11
 }
 
 gfxPlatformGtk::~gfxPlatformGtk()
@@ -652,248 +642,10 @@
 
 #ifdef GL_PROVIDER_GLX
 
-class GLXVsyncSource final : public VsyncSource
-{
-public:
-  GLXVsyncSource()
-  {
-    MOZ_ASSERT(NS_IsMainThread());
-    mGlobalDisplay = new GLXDisplay();
-  }
-
-  virtual ~GLXVsyncSource()
-  {
-    MOZ_ASSERT(NS_IsMainThread());
-  }
-
-  virtual Display& GetGlobalDisplay() override
-  {
-    return *mGlobalDisplay;
-  }
-
-  class GLXDisplay final : public VsyncSource::Display
-  {
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(GLXDisplay)
-
-  public:
-    GLXDisplay() : mGLContext(nullptr)
-                 , mXDisplay(nullptr)
-                 , mSetupLock("GLXVsyncSetupLock")
-                 , mVsyncThread("GLXVsyncThread")
-                 , mVsyncTask(nullptr)
-                 , mVsyncEnabledLock("GLXVsyncEnabledLock")
-                 , mVsyncEnabled(false)
-    {
-    }
-
-    // Sets up the display's GL context on a worker thread.
-    // Required as GLContexts may only be used by the creating thread.
-    // Returns true if setup was a success.
-    bool Setup()
-    {
-      MonitorAutoLock lock(mSetupLock);
-      MOZ_ASSERT(NS_IsMainThread());
-      if (!mVsyncThread.Start())
-        return false;
-
-      RefPtr<Runnable> vsyncSetup = NewRunnableMethod(this, &GLXDisplay::SetupGLContext);
-      mVsyncThread.message_loop()->PostTask(vsyncSetup.forget());
-      // Wait until the setup has completed.
-      lock.Wait();
-      return mGLContext != nullptr;
-    }
-
-    // Called on the Vsync thread to setup the GL context.
-    void SetupGLContext()
-    {
-        MonitorAutoLock lock(mSetupLock);
-        MOZ_ASSERT(!NS_IsMainThread());
-        MOZ_ASSERT(!mGLContext, "GLContext already setup!");
-
-        // Create video sync timer on a separate Display to prevent locking the
-        // main thread X display.
-        mXDisplay = XOpenDisplay(nullptr);
-        if (!mXDisplay) {
-          lock.NotifyAll();
-          return;
-        }
-
-        // Most compositors wait for vsync events on the root window.
-        Window root = DefaultRootWindow(mXDisplay);
-        int screen = DefaultScreen(mXDisplay);
-
-        ScopedXFree<GLXFBConfig> cfgs;
-        GLXFBConfig config;
-        int visid;
-        if (!gl::GLContextGLX::FindFBConfigForWindow(mXDisplay, screen, root,
-                                                     &cfgs, &config, &visid)) {
-          lock.NotifyAll();
-          return;
-        }
-
-        mGLContext = gl::GLContextGLX::CreateGLContext(
-            gl::CreateContextFlags::NONE,
-            gl::SurfaceCaps::Any(),
-            nullptr,
-            false,
-            mXDisplay,
-            root,
-            config,
-            false);
-
-        if (!mGLContext) {
-          lock.NotifyAll();
-          return;
-        }
-
-        mGLContext->MakeCurrent();
-
-        // Test that SGI_video_sync lets us get the counter.
-        unsigned int syncCounter = 0;
-        if (gl::sGLXLibrary.xGetVideoSync(&syncCounter) != 0) {
-          mGLContext = nullptr;
-        }
-
-        lock.NotifyAll();
-    }
-
-    virtual void EnableVsync() override
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-      MOZ_ASSERT(mGLContext, "GLContext not setup!");
-
-      MonitorAutoLock lock(mVsyncEnabledLock);
-      if (mVsyncEnabled) {
-        return;
-      }
-      mVsyncEnabled = true;
-
-      // If the task has not nulled itself out, it hasn't yet realized
-      // that vsync was disabled earlier, so continue its execution.
-      if (!mVsyncTask) {
-        mVsyncTask = NewRunnableMethod(this, &GLXDisplay::RunVsync);
-        RefPtr<Runnable> addrefedTask = mVsyncTask;
-        mVsyncThread.message_loop()->PostTask(addrefedTask.forget());
-      }
-    }
-
-    virtual void DisableVsync() override
-    {
-      MonitorAutoLock lock(mVsyncEnabledLock);
-      mVsyncEnabled = false;
-    }
-
-    virtual bool IsVsyncEnabled() override
-    {
-      MonitorAutoLock lock(mVsyncEnabledLock);
-      return mVsyncEnabled;
-    }
-
-    virtual void Shutdown() override
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-      DisableVsync();
-
-      // Cleanup thread-specific resources before shutting down.
-      RefPtr<Runnable> shutdownTask = NewRunnableMethod(this, &GLXDisplay::Cleanup);
-      mVsyncThread.message_loop()->PostTask(shutdownTask.forget());
-
-      // Stop, waiting for the cleanup task to finish execution.
-      mVsyncThread.Stop();
-    }
-
-  private:
-    virtual ~GLXDisplay()
-    {
-    }
-
-    void RunVsync()
-    {
-      MOZ_ASSERT(!NS_IsMainThread());
-
-      mGLContext->MakeCurrent();
-
-      unsigned int syncCounter = 0;
-      gl::sGLXLibrary.xGetVideoSync(&syncCounter);
-      for (;;) {
-        {
-          MonitorAutoLock lock(mVsyncEnabledLock);
-          if (!mVsyncEnabled) {
-            mVsyncTask = nullptr;
-            return;
-          }
-        }
-
-        TimeStamp lastVsync = TimeStamp::Now();
-        bool useSoftware = false;
-
-        // Wait until the video sync counter reaches the next value by waiting
-        // until the parity of the counter value changes.
-        unsigned int nextSync = syncCounter + 1;
-        int status;
-        if ((status = gl::sGLXLibrary.xWaitVideoSync(2, nextSync % 2, &syncCounter)) != 0) {
-          gfxWarningOnce() << "glXWaitVideoSync returned " << status;
-          useSoftware = true;
-        }
-
-        if (syncCounter == (nextSync - 1)) {
-          gfxWarningOnce() << "glXWaitVideoSync failed to increment the sync counter.";
-          useSoftware = true;
-        }
-
-        if (useSoftware) {
-          double remaining = (1000.f / 60.f) -
-            (TimeStamp::Now() - lastVsync).ToMilliseconds();
-          if (remaining > 0) {
-            PlatformThread::Sleep(remaining);
-          }
-        }
-
-        lastVsync = TimeStamp::Now();
-        NotifyVsync(lastVsync);
-      }
-    }
-
-    void Cleanup() {
-      MOZ_ASSERT(!NS_IsMainThread());
-
-      mGLContext = nullptr;
-      XCloseDisplay(mXDisplay);
-    }
-
-    // Owned by the vsync thread.
-    RefPtr<gl::GLContextGLX> mGLContext;
-    _XDisplay* mXDisplay;
-    Monitor mSetupLock;
-    base::Thread mVsyncThread;
-    RefPtr<Runnable> mVsyncTask;
-    Monitor mVsyncEnabledLock;
-    bool mVsyncEnabled;
-  };
-private:
-  // We need a refcounted VsyncSource::Display to use chromium IPC runnables.
-  RefPtr<GLXDisplay> mGlobalDisplay;
-};
-
 already_AddRefed<gfx::VsyncSource>
 gfxPlatformGtk::CreateHardwareVsyncSource()
 {
-  // Only use GLX vsync when the OpenGL compositor is being used.
-  // The extra cost of initializing a GLX context while blocking the main
-  // thread is not worth it when using basic composition.
-  if (gfxConfig::IsEnabled(Feature::HW_COMPOSITING)) {
-    if (gl::sGLXLibrary.SupportsVideoSync()) {
-      RefPtr<VsyncSource> vsyncSource = new GLXVsyncSource();
-      VsyncSource::Display& display = vsyncSource->GetGlobalDisplay();
-      if (!static_cast<GLXVsyncSource::GLXDisplay&>(display).Setup()) {
-        NS_WARNING("Failed to setup GLContext, falling back to software vsync.");
-        return gfxPlatform::CreateHardwareVsyncSource();
-      }
-      return vsyncSource.forget();
-    }
-    NS_WARNING("SGI_video_sync unsupported. Falling back to software vsync.");
-  }
-  return gfxPlatform::CreateHardwareVsyncSource();
+  return nullptr;
 }
 
 bool
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxPlatformGtk.h gfx/thebes-patched/gfxPlatformGtk.h
--- gfx/thebes/gfxPlatformGtk.h	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxPlatformGtk.h	2016-12-20 18:51:49.000000000 +0100
@@ -107,7 +107,6 @@
 #ifdef MOZ_X11
     virtual void GetAzureBackendInfo(mozilla::widget::InfoObject &aObj) override {
       gfxPlatform::GetAzureBackendInfo(aObj);
-      aObj.DefineProperty("CairoUseXRender", mozilla::gfx::gfxVars::UseXRender());
     }
 #endif
 
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxPlatformMac.cpp gfx/thebes-patched/gfxPlatformMac.cpp
--- gfx/thebes/gfxPlatformMac.cpp	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxPlatformMac.cpp	2016-12-20 18:51:49.000000000 +0100
@@ -377,211 +377,10 @@
   return true;
 }
 
-// This is the renderer output callback function, called on the vsync thread
-static CVReturn VsyncCallback(CVDisplayLinkRef aDisplayLink,
-                              const CVTimeStamp* aNow,
-                              const CVTimeStamp* aOutputTime,
-                              CVOptionFlags aFlagsIn,
-                              CVOptionFlags* aFlagsOut,
-                              void* aDisplayLinkContext);
-
-class OSXVsyncSource final : public VsyncSource
-{
-public:
-  OSXVsyncSource()
-  {
-  }
-
-  virtual Display& GetGlobalDisplay() override
-  {
-    return mGlobalDisplay;
-  }
-
-  class OSXDisplay final : public VsyncSource::Display
-  {
-  public:
-    OSXDisplay()
-      : mDisplayLink(nullptr)
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-      mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
-    }
-
-    ~OSXDisplay()
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-    }
-
-    static void RetryEnableVsync(nsITimer* aTimer, void* aOsxDisplay)
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-      OSXDisplay* osxDisplay = static_cast<OSXDisplay*>(aOsxDisplay);
-      MOZ_ASSERT(osxDisplay);
-      osxDisplay->EnableVsync();
-    }
-
-    virtual void EnableVsync() override
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-      if (IsVsyncEnabled()) {
-        return;
-      }
-
-      // Create a display link capable of being used with all active displays
-      // TODO: See if we need to create an active DisplayLink for each monitor in multi-monitor
-      // situations. According to the docs, it is compatible with all displays running on the computer
-      // But if we have different monitors at different display rates, we may hit issues.
-      if (CVDisplayLinkCreateWithActiveCGDisplays(&mDisplayLink) != kCVReturnSuccess) {
-        NS_WARNING("Could not create a display link with all active displays. Retrying");
-        CVDisplayLinkRelease(mDisplayLink);
-        mDisplayLink = nullptr;
-
-        // bug 1142708 - When coming back from sleep,
-        // or when changing displays, active displays may not be ready yet,
-        // even if listening for the kIOMessageSystemHasPoweredOn event
-        // from OS X sleep notifications.
-        // Active displays are those that are drawable.
-        // bug 1144638 - When changing display configurations and getting
-        // notifications from CGDisplayReconfigurationCallBack, the
-        // callback gets called twice for each active display
-        // so it's difficult to know when all displays are active.
-        // Instead, try again soon. The delay is arbitrary. 100ms chosen
-        // because on a late 2013 15" retina, it takes about that
-        // long to come back up from sleep.
-        uint32_t delay = 100;
-        mTimer->InitWithFuncCallback(RetryEnableVsync, this, delay, nsITimer::TYPE_ONE_SHOT);
-        return;
-      }
-
-      if (CVDisplayLinkSetOutputCallback(mDisplayLink, &VsyncCallback, this) != kCVReturnSuccess) {
-        NS_WARNING("Could not set displaylink output callback");
-        CVDisplayLinkRelease(mDisplayLink);
-        mDisplayLink = nullptr;
-        return;
-      }
-
-      mPreviousTimestamp = TimeStamp::Now();
-      if (CVDisplayLinkStart(mDisplayLink) != kCVReturnSuccess) {
-        NS_WARNING("Could not activate the display link");
-        CVDisplayLinkRelease(mDisplayLink);
-        mDisplayLink = nullptr;
-      }
-
-      CVTime vsyncRate = CVDisplayLinkGetNominalOutputVideoRefreshPeriod(mDisplayLink);
-      if (vsyncRate.flags & kCVTimeIsIndefinite) {
-        NS_WARNING("Could not get vsync rate, setting to 60.");
-        mVsyncRate = TimeDuration::FromMilliseconds(1000.0 / 60.0);
-      } else {
-        int64_t timeValue = vsyncRate.timeValue;
-        int64_t timeScale = vsyncRate.timeScale;
-        const int milliseconds = 1000;
-        float rateInMs = ((double) timeValue / (double) timeScale) * milliseconds;
-        mVsyncRate = TimeDuration::FromMilliseconds(rateInMs);
-      }
-    }
-
-    virtual void DisableVsync() override
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-      if (!IsVsyncEnabled()) {
-        return;
-      }
-
-      // Release the display link
-      if (mDisplayLink) {
-        CVDisplayLinkRelease(mDisplayLink);
-        mDisplayLink = nullptr;
-      }
-    }
-
-    virtual bool IsVsyncEnabled() override
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-      return mDisplayLink != nullptr;
-    }
-
-    virtual TimeDuration GetVsyncRate() override
-    {
-      return mVsyncRate;
-    }
-
-    virtual void Shutdown() override
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-      mTimer->Cancel();
-      mTimer = nullptr;
-      DisableVsync();
-    }
-
-    // The vsync timestamps given by the CVDisplayLinkCallback are
-    // in the future for the NEXT frame. Large parts of Gecko, such
-    // as animations assume a timestamp at either now or in the past.
-    // Normalize the timestamps given to the VsyncDispatchers to the vsync
-    // that just occured, not the vsync that is upcoming.
-    TimeStamp mPreviousTimestamp;
-
-  private:
-    // Manages the display link render thread
-    CVDisplayLinkRef   mDisplayLink;
-    RefPtr<nsITimer> mTimer;
-    TimeDuration mVsyncRate;
-  }; // OSXDisplay
-
-private:
-  virtual ~OSXVsyncSource()
-  {
-  }
-
-  OSXDisplay mGlobalDisplay;
-}; // OSXVsyncSource
-
-static CVReturn VsyncCallback(CVDisplayLinkRef aDisplayLink,
-                              const CVTimeStamp* aNow,
-                              const CVTimeStamp* aOutputTime,
-                              CVOptionFlags aFlagsIn,
-                              CVOptionFlags* aFlagsOut,
-                              void* aDisplayLinkContext)
-{
-  // Executed on OS X hardware vsync thread
-  OSXVsyncSource::OSXDisplay* display = (OSXVsyncSource::OSXDisplay*) aDisplayLinkContext;
-  int64_t nextVsyncTimestamp = aOutputTime->hostTime;
-
-  mozilla::TimeStamp nextVsync = mozilla::TimeStamp::FromSystemTime(nextVsyncTimestamp);
-  mozilla::TimeStamp previousVsync = display->mPreviousTimestamp;
-  mozilla::TimeStamp now = TimeStamp::Now();
-
-  // Snow leopard sometimes sends vsync timestamps very far in the past.
-  // Normalize the vsync timestamps to now.
-  if (nextVsync <= previousVsync) {
-    nextVsync = now;
-    previousVsync = now;
-  } else if (now < previousVsync) {
-    // Bug 1158321 - The VsyncCallback can sometimes execute before the reported
-    // vsync time. In those cases, normalize the timestamp to Now() as sending
-    // timestamps in the future has undefined behavior. See the comment above
-    // OSXDisplay::mPreviousTimestamp
-    previousVsync = now;
-  }
-
-  display->mPreviousTimestamp = nextVsync;
-
-  display->NotifyVsync(previousVsync);
-  return kCVReturnSuccess;
-}
-
 already_AddRefed<mozilla::gfx::VsyncSource>
 gfxPlatformMac::CreateHardwareVsyncSource()
 {
-  RefPtr<VsyncSource> osxVsyncSource = new OSXVsyncSource();
-  VsyncSource::Display& primaryDisplay = osxVsyncSource->GetGlobalDisplay();
-  primaryDisplay.EnableVsync();
-  if (!primaryDisplay.IsVsyncEnabled()) {
-    NS_WARNING("OS X Vsync source not enabled. Falling back to software vsync.");
-    return gfxPlatform::CreateHardwareVsyncSource();
-  }
-
-  primaryDisplay.DisableVsync();
-  return osxVsyncSource.forget();
+  return nullptr;
 }
 
 void
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxSVGGlyphs.cpp gfx/thebes-patched/gfxSVGGlyphs.cpp
--- gfx/thebes/gfxSVGGlyphs.cpp	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxSVGGlyphs.cpp	2016-12-20 19:42:45.000000000 +0100
@@ -23,7 +23,6 @@
 #include "nsIPrincipal.h"
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/dom/Element.h"
-#include "mozilla/LoadInfo.h"
 #include "nsSVGUtils.h"
 #include "nsHostObjectProtocolHandler.h"
 #include "nsContentUtils.h"
@@ -39,38 +38,28 @@
 
 typedef mozilla::dom::Element Element;
 
+#include <string.h>
+#include <stdexcept>
+#include "nsString.h"
+#define STUB(X) throw std::runtime_error (ToNewUTF8String(NS_LITERAL_STRING("[") + NS_LITERAL_STRING(X) + NS_LITERAL_STRING("] Stub method! Must not be called during runtime.")));
+using namespace mozilla::gfx;
+
 /* static */ const Color SimpleTextContextPaint::sZero = Color();
 
 gfxSVGGlyphs::gfxSVGGlyphs(hb_blob_t *aSVGTable, gfxFontEntry *aFontEntry)
-    : mSVGData(aSVGTable)
-    , mFontEntry(aFontEntry)
 {
-    unsigned int length;
-    const char* svgData = hb_blob_get_data(mSVGData, &length);
-    mHeader = reinterpret_cast<const Header*>(svgData);
-    mDocIndex = nullptr;
-
-    if (sizeof(Header) <= length && uint16_t(mHeader->mVersion) == 0 &&
-        uint64_t(mHeader->mDocIndexOffset) + 2 <= length) {
-        const DocIndex* docIndex = reinterpret_cast<const DocIndex*>
-            (svgData + mHeader->mDocIndexOffset);
-        // Limit the number of documents to avoid overflow
-        if (uint64_t(mHeader->mDocIndexOffset) + 2 +
-                uint16_t(docIndex->mNumEntries) * sizeof(IndexEntry) <= length) {
-            mDocIndex = docIndex;
-        }
-    }
+    STUB("gfxSVGGlyphs::gfxSVGGlyphs");
 }
 
 gfxSVGGlyphs::~gfxSVGGlyphs()
 {
-    hb_blob_destroy(mSVGData);
+    STUB("gfxSVGGlyphs::~gfxSVGGlyphs");
 }
 
 void
 gfxSVGGlyphs::DidRefresh()
 {
-    mFontEntry->NotifyGlyphsChanged();
+    STUB("gfxSVGGlyphs::DidRefresh");
 }
 
 /*
@@ -87,102 +76,25 @@
 /* static */ int
 gfxSVGGlyphs::CompareIndexEntries(const void *aKey, const void *aEntry)
 {
-    const uint32_t key = *(uint32_t*)aKey;
-    const IndexEntry *entry = (const IndexEntry*)aEntry;
-
-    if (key < uint16_t(entry->mStartGlyph)) {
-        return -1;
-    }
-    if (key > uint16_t(entry->mEndGlyph)) {
-        return 1;
-    }
-    return 0;
+    STUB("gfxSVGGlyphs::CompareIndexEntries");
 }
 
 gfxSVGGlyphsDocument *
 gfxSVGGlyphs::FindOrCreateGlyphsDocument(uint32_t aGlyphId)
 {
-    if (!mDocIndex) {
-        // Invalid table
-        return nullptr;
-    }
-
-    IndexEntry *entry = (IndexEntry*)bsearch(&aGlyphId, mDocIndex->mEntries,
-                                             uint16_t(mDocIndex->mNumEntries),
-                                             sizeof(IndexEntry),
-                                             CompareIndexEntries);
-    if (!entry) {
-        return nullptr;
-    }
-
-    gfxSVGGlyphsDocument *result = mGlyphDocs.Get(entry->mDocOffset);
-
-    if (!result) {
-        unsigned int length;
-        const uint8_t *data = (const uint8_t*)hb_blob_get_data(mSVGData, &length);
-        if (entry->mDocOffset > 0 &&
-            uint64_t(mHeader->mDocIndexOffset) + entry->mDocOffset + entry->mDocLength <= length) {
-            result = new gfxSVGGlyphsDocument(data + mHeader->mDocIndexOffset + entry->mDocOffset,
-                                              entry->mDocLength, this);
-            mGlyphDocs.Put(entry->mDocOffset, result);
-        }
-    }
-
-    return result;
+    STUB("gfxSVGGlyphs::FindOrCreateGlyphsDocument");
 }
 
 nsresult
 gfxSVGGlyphsDocument::SetupPresentation()
 {
-    nsCOMPtr<nsICategoryManager> catMan = do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
-    nsXPIDLCString contractId;
-    nsresult rv = catMan->GetCategoryEntry("Gecko-Content-Viewers", "image/svg+xml", getter_Copies(contractId));
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    nsCOMPtr<nsIDocumentLoaderFactory> docLoaderFactory = do_GetService(contractId);
-    NS_ASSERTION(docLoaderFactory, "Couldn't get DocumentLoaderFactory");
-
-    nsCOMPtr<nsIContentViewer> viewer;
-    rv = docLoaderFactory->CreateInstanceForDocument(nullptr, mDocument, nullptr, getter_AddRefs(viewer));
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    rv = viewer->Init(nullptr, gfx::IntRect(0, 0, 1000, 1000));
-    if (NS_SUCCEEDED(rv)) {
-        rv = viewer->Open(nullptr, nullptr);
-        NS_ENSURE_SUCCESS(rv, rv);
-    }
-
-    nsCOMPtr<nsIPresShell> presShell;
-    rv = viewer->GetPresShell(getter_AddRefs(presShell));
-    NS_ENSURE_SUCCESS(rv, rv);
-    nsPresContext* presContext = presShell->GetPresContext();
-    presContext->SetIsGlyph(true);
-
-    if (!presShell->DidInitialize()) {
-        nsRect rect = presContext->GetVisibleArea();
-        rv = presShell->Initialize(rect.width, rect.height);
-        NS_ENSURE_SUCCESS(rv, rv);
-    }
-
-    mDocument->FlushPendingNotifications(Flush_Layout);
-
-    nsSMILAnimationController* controller = mDocument->GetAnimationController();
-    if (controller) {
-      controller->Resume(nsSMILTimeContainer::PAUSE_IMAGE);
-    }
-    mDocument->SetImagesNeedAnimating(true);
-
-    mViewer = viewer;
-    mPresShell = presShell;
-    mPresShell->AddPostRefreshObserver(this);
-
-    return NS_OK;
+    STUB("gfxSVGGlyphsDocument::SetupPresentation");
 }
 
 void
 gfxSVGGlyphsDocument::DidRefresh()
 {
-    mOwner->DidRefresh();
+    STUB("gfxSVGGlyphsDocument::DidRefresh");
 }
 
 /**
@@ -193,15 +105,7 @@
 void
 gfxSVGGlyphsDocument::FindGlyphElements(Element *aElem)
 {
-    for (nsIContent *child = aElem->GetLastChild(); child;
-            child = child->GetPreviousSibling()) {
-        if (!child->IsElement()) {
-            continue;
-        }
-        FindGlyphElements(child->AsElement());
-    }
-
-    InsertGlyphId(aElem);
+    STUB("gfxSVGGlyphsDocument::FindGlyphElements");
 }
 
 /**
@@ -215,14 +119,7 @@
 gfxSVGGlyphs::RenderGlyph(gfxContext *aContext, uint32_t aGlyphId,
                           SVGContextPaint* aContextPaint)
 {
-    gfxContextAutoSaveRestore aContextRestorer(aContext);
-
-    Element *glyph = mGlyphIdMap.Get(aGlyphId);
-    NS_ASSERTION(glyph, "No glyph element. Should check with HasSVGGlyph() first!");
-
-    AutoSetRestoreSVGContextPaint autoSetRestore(aContextPaint, glyph->OwnerDoc());
-
-    return nsSVGUtils::PaintSVGGlyph(glyph, aContext);
+    return false;
 }
 
 bool
@@ -276,7 +173,7 @@
 Element *
 gfxSVGGlyphsDocument::GetGlyphElement(uint32_t aGlyphId)
 {
-    return mGlyphIdMap.Get(aGlyphId);
+    STUB("gfxSVGGlyphsDocument::GetGlyphElement");
 }
 
 gfxSVGGlyphsDocument::gfxSVGGlyphsDocument(const uint8_t *aBuffer,
@@ -284,172 +181,31 @@
                                            gfxSVGGlyphs *aSVGGlyphs)
     : mOwner(aSVGGlyphs)
 {
-    ParseDocument(aBuffer, aBufLen);
-    if (!mDocument) {
-        NS_WARNING("Could not parse SVG glyphs document");
-        return;
-    }
-
-    Element *root = mDocument->GetRootElement();
-    if (!root) {
-        NS_WARNING("Could not parse SVG glyphs document");
-        return;
-    }
-
-    nsresult rv = SetupPresentation();
-    if (NS_FAILED(rv)) {
-        NS_WARNING("Couldn't setup presentation for SVG glyphs document");
-        return;
-    }
-
-    FindGlyphElements(root);
+    STUB("gfxSVGGlyphsDocument::gfxSVGGlyphsDocument");
 }
 
 gfxSVGGlyphsDocument::~gfxSVGGlyphsDocument()
 {
-    if (mDocument) {
-        mDocument->OnPageHide(false, nullptr);
-    }
-    if (mPresShell) {
-        mPresShell->RemovePostRefreshObserver(this);
-    }
-    if (mViewer) {
-        mViewer->Close(nullptr);
-        mViewer->Destroy();
-    }
+    STUB("gfxSVGGlyphsDocument::~gfxSVGGlyphsDocument");
 }
 
 static nsresult
 CreateBufferedStream(const uint8_t *aBuffer, uint32_t aBufLen,
                      nsCOMPtr<nsIInputStream> &aResult)
 {
-    nsCOMPtr<nsIInputStream> stream;
-    nsresult rv = NS_NewByteInputStream(getter_AddRefs(stream),
-                                        reinterpret_cast<const char *>(aBuffer),
-                                        aBufLen, NS_ASSIGNMENT_DEPEND);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    nsCOMPtr<nsIInputStream> aBufferedStream;
-    if (!NS_InputStreamIsBuffered(stream)) {
-        rv = NS_NewBufferedInputStream(getter_AddRefs(aBufferedStream), stream, 4096);
-        NS_ENSURE_SUCCESS(rv, rv);
-        stream = aBufferedStream;
-    }
-
-    aResult = stream;
-
-    return NS_OK;
+    STUB("gfxSVGGlyphsDocument::CreateBufferedStream");
 }
 
 nsresult
 gfxSVGGlyphsDocument::ParseDocument(const uint8_t *aBuffer, uint32_t aBufLen)
 {
-    // Mostly pulled from nsDOMParser::ParseFromStream
-
-    nsCOMPtr<nsIInputStream> stream;
-    nsresult rv = CreateBufferedStream(aBuffer, aBufLen, stream);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    nsCOMPtr<nsIURI> uri;
-    nsHostObjectProtocolHandler::GenerateURIString(NS_LITERAL_CSTRING(FONTTABLEURI_SCHEME),
-                                                   nullptr,
-                                                   mSVGGlyphsDocumentURI);
- 
-    rv = NS_NewURI(getter_AddRefs(uri), mSVGGlyphsDocumentURI);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    nsCOMPtr<nsIPrincipal> principal = nsNullPrincipal::Create();
-
-    nsCOMPtr<nsIDOMDocument> domDoc;
-    rv = NS_NewDOMDocument(getter_AddRefs(domDoc),
-                           EmptyString(),   // aNamespaceURI
-                           EmptyString(),   // aQualifiedName
-                           nullptr,          // aDoctype
-                           uri, uri, principal,
-                           false,           // aLoadedAsData
-                           nullptr,          // aEventObject
-                           DocumentFlavorSVG);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    nsCOMPtr<nsIDocument> document(do_QueryInterface(domDoc));
-    if (!document) {
-        return NS_ERROR_FAILURE;
-    }
-
-    nsCOMPtr<nsIChannel> channel;
-    rv = NS_NewInputStreamChannel(getter_AddRefs(channel),
-                                  uri,
-                                  nullptr, //aStream
-                                  principal,
-                                  nsILoadInfo::SEC_FORCE_INHERIT_PRINCIPAL,
-                                  nsIContentPolicy::TYPE_OTHER,
-                                  SVG_CONTENT_TYPE,
-                                  UTF8_CHARSET);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    // Set this early because various decisions during page-load depend on it.
-    document->SetIsBeingUsedAsImage();
-    document->SetReadyStateInternal(nsIDocument::READYSTATE_UNINITIALIZED);
-
-    nsCOMPtr<nsIStreamListener> listener;
-    rv = document->StartDocumentLoad("external-resource", channel,
-                                     nullptr,    // aLoadGroup
-                                     nullptr,    // aContainer
-                                     getter_AddRefs(listener),
-                                     true /* aReset */);
-    if (NS_FAILED(rv) || !listener) {
-        return NS_ERROR_FAILURE;
-    }
-
-    rv = listener->OnStartRequest(channel, nullptr /* aContext */);
-    if (NS_FAILED(rv)) {
-        channel->Cancel(rv);
-    }
-
-    nsresult status;
-    channel->GetStatus(&status);
-    if (NS_SUCCEEDED(rv) && NS_SUCCEEDED(status)) {
-        rv = listener->OnDataAvailable(channel, nullptr /* aContext */, stream, 0, aBufLen);
-        if (NS_FAILED(rv)) {
-            channel->Cancel(rv);
-        }
-        channel->GetStatus(&status);
-    }
-
-    rv = listener->OnStopRequest(channel, nullptr /* aContext */, status);
-    NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
-
-    document.swap(mDocument);
-
-    return NS_OK;
+    STUB("gfxSVGGlyphsDocument::ParseDocument");
 }
 
 void
 gfxSVGGlyphsDocument::InsertGlyphId(Element *aGlyphElement)
 {
-    nsAutoString glyphIdStr;
-    static const uint32_t glyphPrefixLength = 5;
-    // The maximum glyph ID is 65535 so the maximum length of the numeric part
-    // is 5.
-    if (!aGlyphElement->GetAttr(kNameSpaceID_None, nsGkAtoms::id, glyphIdStr) ||
-        !StringBeginsWith(glyphIdStr, NS_LITERAL_STRING("glyph")) ||
-        glyphIdStr.Length() > glyphPrefixLength + 5) {
-        return;
-    }
-
-    uint32_t id = 0;
-    for (uint32_t i = glyphPrefixLength; i < glyphIdStr.Length(); ++i) {
-      char16_t ch = glyphIdStr.CharAt(i);
-      if (ch < '0' || ch > '9') {
-        return;
-      }
-      if (ch == '0' && i == glyphPrefixLength) {
-        return;
-      }
-      id = id * 10 + (ch - '0');
-    }
-
-    mGlyphIdMap.Put(id, aGlyphElement);
+    STUB("gfxSVGGlyphsDocument::InsertGlyphId");
 }
 
 size_t
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxUserFontSet.cpp gfx/thebes-patched/gfxUserFontSet.cpp
--- gfx/thebes/gfxUserFontSet.cpp	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxUserFontSet.cpp	2016-12-20 18:51:49.000000000 +0100
@@ -472,78 +472,6 @@
                                                       &bypassCache);
 
                 if (NS_SUCCEEDED(rv) && principal != nullptr) {
-                    if (!bypassCache) {
-                        // see if we have an existing entry for this source
-                        gfxFontEntry* fe = gfxUserFontSet::
-                            UserFontCache::GetFont(currSrc.mURI,
-                                                   principal,
-                                                   this,
-                                                   mFontSet->GetPrivateBrowsing());
-                        if (fe) {
-                            mPlatformFontEntry = fe;
-                            SetLoadState(STATUS_LOADED);
-                            if (LOG_ENABLED()) {
-                                LOG(("userfonts (%p) [src %d] "
-                                     "loaded uri from cache: (%s) for (%s)\n",
-                                     mFontSet, mSrcIndex,
-                                     currSrc.mURI->GetSpecOrDefault().get(),
-                                     NS_ConvertUTF16toUTF8(mFamilyName).get()));
-                            }
-                            return;
-                        }
-                    }
-
-                    // record the principal returned by CheckFontLoad,
-                    // for use when creating a channel
-                    // and when caching the loaded entry
-                    mPrincipal = principal;
-
-                    bool loadDoesntSpin = false;
-                    rv = NS_URIChainHasFlags(currSrc.mURI,
-                           nsIProtocolHandler::URI_SYNC_LOAD_IS_OK,
-                           &loadDoesntSpin);
-
-                    if (NS_SUCCEEDED(rv) && loadDoesntSpin) {
-                        uint8_t* buffer = nullptr;
-                        uint32_t bufferLength = 0;
-
-                        // sync load font immediately
-                        rv = mFontSet->SyncLoadFontData(this, &currSrc, buffer,
-                                                        bufferLength);
-
-                        if (NS_SUCCEEDED(rv) &&
-                            LoadPlatformFont(buffer, bufferLength)) {
-                            SetLoadState(STATUS_LOADED);
-                            Telemetry::Accumulate(Telemetry::WEBFONT_SRCTYPE,
-                                                  currSrc.mSourceType + 1);
-                            return;
-                        } else {
-                            mFontSet->LogMessage(this,
-                                                 "font load failed",
-                                                 nsIScriptError::errorFlag,
-                                                 rv);
-                        }
-
-                    } else {
-                        // otherwise load font async
-                        rv = mFontSet->StartLoad(this, &currSrc);
-                        bool loadOK = NS_SUCCEEDED(rv);
-
-                        if (loadOK) {
-                            if (LOG_ENABLED()) {
-                                LOG(("userfonts (%p) [src %d] loading uri: (%s) for (%s)\n",
-                                     mFontSet, mSrcIndex,
-                                     currSrc.mURI->GetSpecOrDefault().get(),
-                                     NS_ConvertUTF16toUTF8(mFamilyName).get()));
-                            }
-                            return;
-                        } else {
-                            mFontSet->LogMessage(this,
-                                                 "download failed",
-                                                 nsIScriptError::errorFlag,
-                                                 rv);
-                        }
-                    }
                 } else {
                     mFontSet->LogMessage(this, "download not allowed",
                                          nsIScriptError::errorFlag, rv);
@@ -1077,12 +1005,7 @@
 static bool
 IgnorePrincipal(nsIURI* aURI)
 {
-    nsresult rv;
-    bool inherits = false;
-    rv = NS_URIChainHasFlags(aURI,
-                             nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT,
-                             &inherits);
-    return NS_SUCCEEDED(rv) && inherits;
+   return true;
 }
 
 bool
@@ -1132,68 +1055,6 @@
 gfxUserFontSet::UserFontCache::CacheFont(gfxFontEntry* aFontEntry,
                                          EntryPersistence aPersistence)
 {
-    NS_ASSERTION(aFontEntry->mFamilyName.Length() != 0,
-                 "caching a font associated with no family yet");
-
-    // if caching is disabled, simply return
-    if (Preferences::GetBool("gfx.downloadable_fonts.disable_cache")) {
-        return;
-    }
-
-    gfxUserFontData* data = aFontEntry->mUserFontData.get();
-    if (data->mIsBuffer) {
-#ifdef DEBUG_USERFONT_CACHE
-        printf("userfontcache skipped fontentry with buffer source: %p\n",
-               aFontEntry);
-#endif
-        return;
-    }
-
-    if (!sUserFonts) {
-        sUserFonts = new nsTHashtable<Entry>;
-
-        nsCOMPtr<nsIObserverService> obs =
-            mozilla::services::GetObserverService();
-        if (obs) {
-            Flusher* flusher = new Flusher;
-            obs->AddObserver(flusher, "cacheservice:empty-cache",
-                             false);
-            obs->AddObserver(flusher, "last-pb-context-exited", false);
-            obs->AddObserver(flusher, "xpcom-shutdown", false);
-        }
-
-        // Create and register a memory reporter for sUserFonts.
-        // This reporter is never unregistered, but that's OK because
-        // the reporter checks whether sUserFonts is null, so it would
-        // be safe to call even after UserFontCache::Shutdown has deleted
-        // the cache.
-        RegisterStrongMemoryReporter(new MemoryReporter());
-    }
-
-    if (data->mLength) {
-        MOZ_ASSERT(aPersistence == kPersistent);
-        MOZ_ASSERT(!data->mPrivate);
-        sUserFonts->PutEntry(Key(data->mCRC32, data->mLength, aFontEntry,
-                                 data->mPrivate, aPersistence));
-    } else {
-        MOZ_ASSERT(aPersistence == kDiscardable);
-        // For data: URIs, the principal is ignored; anyone who has the same
-        // data: URI is able to load it and get an equivalent font.
-        // Otherwise, the principal is used as part of the cache key.
-        nsIPrincipal* principal;
-        if (IgnorePrincipal(data->mURI)) {
-            principal = nullptr;
-        } else {
-            principal = data->mPrincipal;
-        }
-        sUserFonts->PutEntry(Key(data->mURI, principal, aFontEntry,
-                                 data->mPrivate, aPersistence));
-    }
-
-#ifdef DEBUG_USERFONT_CACHE
-    printf("userfontcache added fontentry: %p\n", aFontEntry);
-    Dump();
-#endif
 }
 
 void
@@ -1226,62 +1087,6 @@
                                        gfxUserFontEntry* aUserFontEntry,
                                        bool aPrivate)
 {
-    if (!sUserFonts ||
-        Preferences::GetBool("gfx.downloadable_fonts.disable_cache")) {
-        return nullptr;
-    }
-
-    // We have to perform another content policy check here to prevent
-    // cache poisoning. E.g. a.com loads a font into the cache but
-    // b.com has a CSP not allowing any fonts to be loaded.
-    if (!aUserFontEntry->mFontSet->IsFontLoadAllowed(aSrcURI, aPrincipal)) {
-        return nullptr;
-    }
-
-    // Ignore principal when looking up a data: URI.
-    nsIPrincipal* principal;
-    if (IgnorePrincipal(aSrcURI)) {
-        principal = nullptr;
-    } else {
-        principal = aPrincipal;
-    }
-
-    Entry* entry = sUserFonts->GetEntry(Key(aSrcURI, principal, aUserFontEntry,
-                                            aPrivate));
-    if (entry) {
-        return entry->GetFontEntry();
-    }
-
-    // The channel is never openend; to be conservative we use the most
-    // restrictive security flag: SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS.
-    nsCOMPtr<nsIChannel> chan;
-    if (NS_FAILED(NS_NewChannel(getter_AddRefs(chan),
-                                aSrcURI,
-                                aPrincipal,
-                                nsILoadInfo::SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS,
-                                nsIContentPolicy::TYPE_FONT))) {
-        return nullptr;
-    }
-
-    nsCOMPtr<nsIJARChannel> jarchan = do_QueryInterface(chan);
-    if (!jarchan) {
-        return nullptr;
-    }
-
-    nsCOMPtr<nsIZipEntry> zipentry;
-    if (NS_FAILED(jarchan->GetZipEntry(getter_AddRefs(zipentry)))) {
-        return nullptr;
-    }
-
-    uint32_t crc32, length;
-    zipentry->GetCRC32(&crc32);
-    zipentry->GetRealSize(&length);
-
-    entry = sUserFonts->GetEntry(Key(crc32, length, aUserFontEntry, aPrivate));
-    if (entry) {
-        return entry->GetFontEntry();
-    }
-
     return nullptr;
 }
 
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxUtils.cpp gfx/thebes-patched/gfxUtils.cpp
--- gfx/thebes/gfxUtils.cpp	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxUtils.cpp	2016-12-20 20:27:28.000000000 +0100
@@ -370,13 +370,6 @@
     return destSurf.forget();
 }
 
-void
-gfxUtils::ConvertBGRAtoRGBA(uint8_t* aData, uint32_t aLength)
-{
-    MOZ_ASSERT((aLength % 4) == 0, "Loop below will pass srcEnd!");
-    libyuv::ABGRToARGB(aData, aLength, aData, aLength, aLength / 4, 1);
-}
-
 #if !defined(MOZ_GFX_OPTIMIZE_MOBILE)
 /**
  * This returns the fastest operator to use for solid surfaces which have no
@@ -1286,161 +1279,6 @@
   }
 }
 
-/* static */ UniquePtr<uint8_t[]>
-gfxUtils::GetImageBuffer(gfx::DataSourceSurface* aSurface,
-                         bool aIsAlphaPremultiplied,
-                         int32_t* outFormat)
-{
-    *outFormat = 0;
-
-    DataSourceSurface::MappedSurface map;
-    if (!aSurface->Map(DataSourceSurface::MapType::READ, &map))
-        return nullptr;
-
-    uint32_t bufferSize = aSurface->GetSize().width * aSurface->GetSize().height * 4;
-    auto imageBuffer = MakeUniqueFallible<uint8_t[]>(bufferSize);
-    if (!imageBuffer) {
-        aSurface->Unmap();
-        return nullptr;
-    }
-    memcpy(imageBuffer.get(), map.mData, bufferSize);
-
-    aSurface->Unmap();
-
-    int32_t format = imgIEncoder::INPUT_FORMAT_HOSTARGB;
-    if (!aIsAlphaPremultiplied) {
-        // We need to convert to INPUT_FORMAT_RGBA, otherwise
-        // we are automatically considered premult, and unpremult'd.
-        // Yes, it is THAT silly.
-        // Except for different lossy conversions by color,
-        // we could probably just change the label, and not change the data.
-        gfxUtils::ConvertBGRAtoRGBA(imageBuffer.get(), bufferSize);
-        format = imgIEncoder::INPUT_FORMAT_RGBA;
-    }
-
-    *outFormat = format;
-    return imageBuffer;
-}
-
-/* static */ nsresult
-gfxUtils::GetInputStream(gfx::DataSourceSurface* aSurface,
-                         bool aIsAlphaPremultiplied,
-                         const char* aMimeType,
-                         const char16_t* aEncoderOptions,
-                         nsIInputStream** outStream)
-{
-    nsCString enccid("@mozilla.org/image/encoder;2?type=");
-    enccid += aMimeType;
-    nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(enccid.get());
-    if (!encoder)
-        return NS_ERROR_FAILURE;
-
-    int32_t format = 0;
-    UniquePtr<uint8_t[]> imageBuffer = GetImageBuffer(aSurface, aIsAlphaPremultiplied, &format);
-    if (!imageBuffer)
-        return NS_ERROR_FAILURE;
-
-    return dom::ImageEncoder::GetInputStream(aSurface->GetSize().width,
-                                             aSurface->GetSize().height,
-                                             imageBuffer.get(), format,
-                                             encoder, aEncoderOptions, outStream);
-}
-
-class GetFeatureStatusRunnable final : public dom::workers::WorkerMainThreadRunnable
-{
-public:
-    GetFeatureStatusRunnable(dom::workers::WorkerPrivate* workerPrivate,
-                             const nsCOMPtr<nsIGfxInfo>& gfxInfo,
-                             int32_t feature,
-                             nsACString& failureId,
-                             int32_t* status)
-      : WorkerMainThreadRunnable(workerPrivate,
-                                 NS_LITERAL_CSTRING("GFX :: GetFeatureStatus"))
-      , mGfxInfo(gfxInfo)
-      , mFeature(feature)
-      , mStatus(status)
-      , mFailureId(failureId)
-      , mNSResult(NS_OK)
-    {
-    }
-
-    bool MainThreadRun() override
-    {
-      if (mGfxInfo) {
-        mNSResult = mGfxInfo->GetFeatureStatus(mFeature, mFailureId, mStatus);
-      }
-      return true;
-    }
-
-    nsresult GetNSResult() const
-    {
-      return mNSResult;
-    }
-
-protected:
-    ~GetFeatureStatusRunnable() {}
-
-private:
-    nsCOMPtr<nsIGfxInfo> mGfxInfo;
-    int32_t mFeature;
-    int32_t* mStatus;
-    nsACString& mFailureId;
-    nsresult mNSResult;
-};
-
-/* static */ nsresult
-gfxUtils::ThreadSafeGetFeatureStatus(const nsCOMPtr<nsIGfxInfo>& gfxInfo,
-                                     int32_t feature, nsACString& failureId,
-                                     int32_t* status)
-{
-  if (!NS_IsMainThread()) {
-    dom::workers::WorkerPrivate* workerPrivate =
-      dom::workers::GetCurrentThreadWorkerPrivate();
-
-    RefPtr<GetFeatureStatusRunnable> runnable =
-      new GetFeatureStatusRunnable(workerPrivate, gfxInfo, feature, failureId,
-                                   status);
-
-    ErrorResult rv;
-    runnable->Dispatch(rv);
-    if (rv.Failed()) {
-        // XXXbz This is totally broken, since we're supposed to just abort
-        // everything up the callstack but the callers basically eat the
-        // exception.  Ah, well.
-        return rv.StealNSResult();
-    }
-
-    return runnable->GetNSResult();
-  }
-
-  return gfxInfo->GetFeatureStatus(feature, failureId, status);
-}
-
-/* static */ bool
-gfxUtils::IsFeatureBlacklisted(nsCOMPtr<nsIGfxInfo> gfxInfo, int32_t feature,
-                               nsACString* const out_blacklistId)
-{
-  if (!gfxInfo) {
-    gfxInfo = services::GetGfxInfo();
-  }
-
-  int32_t status;
-  if (!NS_SUCCEEDED(gfxUtils::ThreadSafeGetFeatureStatus(gfxInfo, feature,
-                                                         *out_blacklistId, &status)))
-  {
-    out_blacklistId->AssignLiteral("");
-    return true;
-  }
-
-  return status != nsIGfxInfo::FEATURE_STATUS_OK;
-}
-
-/* static */ bool
-gfxUtils::DumpDisplayList() {
-  return gfxPrefs::LayoutDumpDisplayList() ||
-         (gfxPrefs::LayoutDumpDisplayListContent() && XRE_IsContentProcess());
-}
-
 FILE *gfxUtils::sDumpPaintFile = stderr;
 
 namespace mozilla {
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxWindowsPlatform.cpp gfx/thebes-patched/gfxWindowsPlatform.cpp
--- gfx/thebes/gfxWindowsPlatform.cpp	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxWindowsPlatform.cpp	2016-12-20 18:51:49.000000000 +0100
@@ -446,10 +446,6 @@
   mHasD3D9DeviceReset = false;
   mDeviceResetReason = DeviceResetReason::OK;
 
-  imgLoader::NormalLoader()->ClearCache(true);
-  imgLoader::NormalLoader()->ClearCache(false);
-  imgLoader::PrivateBrowsingLoader()->ClearCache(true);
-  imgLoader::PrivateBrowsingLoader()->ClearCache(false);
   gfxAlphaBoxBlur::ShutdownBlurCache();
 
   if (XRE_IsContentProcess()) {
@@ -1330,16 +1326,6 @@
   mHasD3D9DeviceReset = true;
 }
 
-ReadbackManagerD3D11*
-gfxWindowsPlatform::GetReadbackManager()
-{
-  if (!mD3D11ReadbackManager) {
-    mD3D11ReadbackManager = new ReadbackManagerD3D11();
-  }
-
-  return mD3D11ReadbackManager;
-}
-
 bool
 gfxWindowsPlatform::IsOptimus()
 {
@@ -1664,309 +1650,13 @@
 bool
 gfxWindowsPlatform::DwmCompositionEnabled()
 {
-  if (!IsVistaOrLater()) {
-    return false;
-  }
-
-  MOZ_ASSERT(WinUtils::dwmIsCompositionEnabledPtr);
-  BOOL dwmEnabled = false;
-
-  if (FAILED(WinUtils::dwmIsCompositionEnabledPtr(&dwmEnabled))) {
-    return false;
-  }
-
-  return dwmEnabled;
+  return false;
 }
 
-class D3DVsyncSource final : public VsyncSource
-{
-public:
-
-  class D3DVsyncDisplay final : public VsyncSource::Display
-  {
-    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(D3DVsyncDisplay)
-    public:
-      D3DVsyncDisplay()
-        : mPrevVsync(TimeStamp::Now())
-        , mVsyncEnabledLock("D3DVsyncEnabledLock")
-        , mVsyncEnabled(false)
-      {
-        mVsyncThread = new base::Thread("WindowsVsyncThread");
-        MOZ_RELEASE_ASSERT(mVsyncThread->Start(), "GFX: Could not start Windows vsync thread");
-        SetVsyncRate();
-      }
-
-      void SetVsyncRate()
-      {
-        if (!gfxWindowsPlatform::GetPlatform()->DwmCompositionEnabled()) {
-          mVsyncRate = TimeDuration::FromMilliseconds(1000.0 / 60.0);
-          return;
-        }
-
-        DWM_TIMING_INFO vblankTime;
-        // Make sure to init the cbSize, otherwise GetCompositionTiming will fail
-        vblankTime.cbSize = sizeof(DWM_TIMING_INFO);
-        HRESULT hr = WinUtils::dwmGetCompositionTimingInfoPtr(0, &vblankTime);
-        if (SUCCEEDED(hr)) {
-          UNSIGNED_RATIO refreshRate = vblankTime.rateRefresh;
-          // We get the rate in hertz / time, but we want the rate in ms.
-          float rate = ((float) refreshRate.uiDenominator
-                       / (float) refreshRate.uiNumerator) * 1000;
-          mVsyncRate = TimeDuration::FromMilliseconds(rate);
-        } else {
-          mVsyncRate = TimeDuration::FromMilliseconds(1000.0 / 60.0);
-        }
-      }
-
-      virtual void Shutdown() override
-      {
-        MOZ_ASSERT(NS_IsMainThread());
-        DisableVsync();
-        mVsyncThread->Stop();
-        delete mVsyncThread;
-      }
-
-      virtual void EnableVsync() override
-      {
-        MOZ_ASSERT(NS_IsMainThread());
-        MOZ_ASSERT(mVsyncThread->IsRunning());
-        { // scope lock
-          MonitorAutoLock lock(mVsyncEnabledLock);
-          if (mVsyncEnabled) {
-            return;
-          }
-          mVsyncEnabled = true;
-        }
-
-        mVsyncThread->message_loop()->PostTask(
-            NewRunnableMethod(this, &D3DVsyncDisplay::VBlankLoop));
-      }
-
-      virtual void DisableVsync() override
-      {
-        MOZ_ASSERT(NS_IsMainThread());
-        MOZ_ASSERT(mVsyncThread->IsRunning());
-        MonitorAutoLock lock(mVsyncEnabledLock);
-        if (!mVsyncEnabled) {
-          return;
-        }
-        mVsyncEnabled = false;
-      }
-
-      virtual bool IsVsyncEnabled() override
-      {
-        MOZ_ASSERT(NS_IsMainThread());
-        MonitorAutoLock lock(mVsyncEnabledLock);
-        return mVsyncEnabled;
-      }
-
-      virtual TimeDuration GetVsyncRate() override
-      {
-        return mVsyncRate;
-      }
-
-      void ScheduleSoftwareVsync(TimeStamp aVsyncTimestamp)
-      {
-        MOZ_ASSERT(IsInVsyncThread());
-        NS_WARNING("DwmComposition dynamically disabled, falling back to software timers");
-
-        TimeStamp nextVsync = aVsyncTimestamp + mVsyncRate;
-        TimeDuration delay = nextVsync - TimeStamp::Now();
-        if (delay.ToMilliseconds() < 0) {
-          delay = mozilla::TimeDuration::FromMilliseconds(0);
-        }
-
-        mVsyncThread->message_loop()->PostDelayedTask(
-            NewRunnableMethod(this, &D3DVsyncDisplay::VBlankLoop),
-            delay.ToMilliseconds());
-      }
-
-      // Returns the timestamp for the just happened vsync
-      TimeStamp GetVBlankTime()
-      {
-        TimeStamp vsync = TimeStamp::Now();
-        TimeStamp now = vsync;
-
-        DWM_TIMING_INFO vblankTime;
-        // Make sure to init the cbSize, otherwise
-        // GetCompositionTiming will fail
-        vblankTime.cbSize = sizeof(DWM_TIMING_INFO);
-        HRESULT hr = WinUtils::dwmGetCompositionTimingInfoPtr(0, &vblankTime);
-        if (!SUCCEEDED(hr)) {
-            return vsync;
-        }
-
-        LARGE_INTEGER frequency;
-        QueryPerformanceFrequency(&frequency);
-
-        LARGE_INTEGER qpcNow;
-        QueryPerformanceCounter(&qpcNow);
-
-        const int microseconds = 1000000;
-        int64_t adjust = qpcNow.QuadPart - vblankTime.qpcVBlank;
-        int64_t usAdjust = (adjust * microseconds) / frequency.QuadPart;
-        vsync -= TimeDuration::FromMicroseconds((double) usAdjust);
-
-        if (IsWin10OrLater()) {
-          // On Windows 10 and on, DWMGetCompositionTimingInfo, mostly
-          // reports the upcoming vsync time, which is in the future.
-          // It can also sometimes report a vblank time in the past.
-          // Since large parts of Gecko assume TimeStamps can't be in future,
-          // use the previous vsync.
-
-          // Windows 10 and Intel HD vsync timestamps are messy and
-          // all over the place once in a while. Most of the time,
-          // it reports the upcoming vsync. Sometimes, that upcoming
-          // vsync is in the past. Sometimes that upcoming vsync is before
-          // the previously seen vsync.
-          // In these error cases, normalize to Now();
-          if (vsync >= now) {
-            vsync = vsync - mVsyncRate;
-          }
-        }
-
-        // On Windows 7 and 8, DwmFlush wakes up AFTER qpcVBlankTime
-        // from DWMGetCompositionTimingInfo. We can return the adjusted vsync.
-        if (vsync >= now) {
-            vsync = now;
-        }
-
-        // Our vsync time is some time very far in the past, adjust to Now.
-        // 4 ms is arbitrary, so feel free to pick something else if this isn't
-        // working. See the comment above within IsWin10OrLater().
-        if ((now - vsync).ToMilliseconds() > 4.0) {
-            vsync = now;
-        }
-
-        return vsync;
-      }
-
-      void VBlankLoop()
-      {
-        MOZ_ASSERT(IsInVsyncThread());
-        MOZ_ASSERT(sizeof(int64_t) == sizeof(QPC_TIME));
-
-        TimeStamp vsync = TimeStamp::Now();
-        mPrevVsync = TimeStamp();
-        TimeStamp flushTime = TimeStamp::Now();
-        TimeDuration longVBlank = mVsyncRate * 2;
-
-        for (;;) {
-          { // scope lock
-            MonitorAutoLock lock(mVsyncEnabledLock);
-            if (!mVsyncEnabled) return;
-          }
-
-          // Large parts of gecko assume that the refresh driver timestamp
-          // must be <= Now() and cannot be in the future.
-          MOZ_ASSERT(vsync <= TimeStamp::Now());
-          Display::NotifyVsync(vsync);
-
-          // DwmComposition can be dynamically enabled/disabled
-          // so we have to check every time that it's available.
-          // When it is unavailable, we fallback to software but will try
-          // to get back to dwm rendering once it's re-enabled
-          if (!gfxWindowsPlatform::GetPlatform()->DwmCompositionEnabled()) {
-            ScheduleSoftwareVsync(vsync);
-            return;
-          }
-
-          // Using WaitForVBlank, the whole system dies because WaitForVBlank
-          // only works if it's run on the same thread as the Present();
-          HRESULT hr = WinUtils::dwmFlushProcPtr();
-          if (!SUCCEEDED(hr)) {
-            // DWMFlush isn't working, fallback to software vsync.
-            ScheduleSoftwareVsync(TimeStamp::Now());
-            return;
-          }
-
-          TimeStamp now = TimeStamp::Now();
-          TimeDuration flushDiff = now - flushTime;
-          flushTime = now;
-          if ((flushDiff > longVBlank) || mPrevVsync.IsNull()) {
-            // Our vblank took longer than 2 intervals, readjust our timestamps
-            vsync = GetVBlankTime();
-            mPrevVsync = vsync;
-          } else {
-            // Instead of giving the actual vsync time, a constant interval
-            // between vblanks instead of the noise generated via hardware
-            // is actually what we want. Most apps just care about the diff
-            // between vblanks to animate, so a clean constant interval is
-            // smoother.
-            vsync = mPrevVsync + mVsyncRate;
-            if (vsync > now) {
-              // DWMFlush woke up very early, so readjust our times again
-              vsync = GetVBlankTime();
-            }
-
-            if (vsync <= mPrevVsync) {
-              vsync = TimeStamp::Now();
-            }
-
-            if ((now - vsync).ToMilliseconds() > 2.0) {
-              // Account for time drift here where vsync never quite catches up to
-              // Now and we'd fall ever so slightly further behind Now().
-              vsync = GetVBlankTime();
-            }
-
-            mPrevVsync = vsync;
-          }
-        } // end for
-      }
-
-    private:
-      virtual ~D3DVsyncDisplay()
-      {
-        MOZ_ASSERT(NS_IsMainThread());
-      }
-
-      bool IsInVsyncThread()
-      {
-        return mVsyncThread->thread_id() == PlatformThread::CurrentId();
-      }
-
-      TimeStamp mPrevVsync;
-      Monitor mVsyncEnabledLock;
-      base::Thread* mVsyncThread;
-      TimeDuration mVsyncRate;
-      bool mVsyncEnabled;
-  }; // end d3dvsyncdisplay
-
-  D3DVsyncSource()
-  {
-    mPrimaryDisplay = new D3DVsyncDisplay();
-  }
-
-  virtual Display& GetGlobalDisplay() override
-  {
-    return *mPrimaryDisplay;
-  }
-
-private:
-  virtual ~D3DVsyncSource()
-  {
-  }
-  RefPtr<D3DVsyncDisplay> mPrimaryDisplay;
-}; // end D3DVsyncSource
-
 already_AddRefed<mozilla::gfx::VsyncSource>
 gfxWindowsPlatform::CreateHardwareVsyncSource()
 {
-  MOZ_RELEASE_ASSERT(NS_IsMainThread(), "GFX: Not in main thread.");
-  if (!WinUtils::dwmIsCompositionEnabledPtr) {
-    NS_WARNING("Dwm composition not available, falling back to software vsync");
-    return gfxPlatform::CreateHardwareVsyncSource();
-  }
-
-  BOOL dwmEnabled = false;
-  WinUtils::dwmIsCompositionEnabledPtr(&dwmEnabled);
-  if (!dwmEnabled) {
-    NS_WARNING("DWM not enabled, falling back to software vsync");
-    return gfxPlatform::CreateHardwareVsyncSource();
-  }
-
-  RefPtr<VsyncSource> d3dVsyncSource = new D3DVsyncSource();
-  return d3dVsyncSource.forget();
+  return nullptr;
 }
 
 bool
diff -Naur --exclude '.*' --exclude '*.pyc' --exclude '*.orig' --exclude '*.rej' gfx/thebes/gfxWindowsPlatform.h gfx/thebes-patched/gfxWindowsPlatform.h
--- gfx/thebes/gfxWindowsPlatform.h	2016-09-19 12:14:36.000000000 +0200
+++ gfx/thebes-patched/gfxWindowsPlatform.h	2016-12-20 18:51:49.000000000 +0100
@@ -215,8 +215,6 @@
 
     bool DwmCompositionEnabled();
 
-    mozilla::layers::ReadbackManagerD3D11* GetReadbackManager();
-
     static bool IsOptimus();
 
     bool SupportsApzWheelInput() const override {
@@ -286,8 +284,6 @@
     mozilla::Atomic<bool> mHasD3D9DeviceReset;
     DeviceResetReason mDeviceResetReason;
 
-    RefPtr<mozilla::layers::ReadbackManagerD3D11> mD3D11ReadbackManager;
-
     nsTArray<D3D_FEATURE_LEVEL> mFeatureLevels;
 };
 
